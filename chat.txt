### USER
I want to build a javascript library, packaged so that I can add it to a GitHub repo and use it via jsDeliver, for working with publications of the Homer Multitext project (HMT). The library should use the `cex-lib.js` library to read and manipulate HMT publications in CiteEXchange (CEX) format, and the `urns-lib.js` library for working with CTS and CITE2 URNs. I have attached complete documentation of the two libraries in the attached files `cex-lib.js` and `cex-apis.md`.
  
  
  
The first function I want to implement, `hmtcurrent`, will simply load a CEX data source from the URL `https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex` using `CEXParser.loadFromUrl`, and return the resulting `CEXParser`.
  
**Test**: Please implement this and write an HTML using `hmtcurrent`. Display the output of using `loadFromUrl()` with the returned parser.

### ASSISTANT
Okay, I can help you implement the `hmtcurrent` function for your JavaScript library and create an HTML test page.

This `hmtcurrent` function will use `cex-lib.js` to load CEX data from the specified HMT URL. The function will be part of a simple library structure, `HMTLib`, making it easy to expand later.

Here's the implementation:

**1. `hmt-lib.js` (Your new library file)**

This file will contain the `hmtcurrent` function, packaged within a namespace `HMTLib`.

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * This function utilizes CEXParser.loadFromUrl from cex-lib.js.
     *
     * It assumes CEXParser is available in the global scope (from including cex-lib.js).
     *
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance
     *                               loaded with the HMT data. If loading fails or
     *                               CEXParser is not found, the Promise will be rejected
     *                               with an Error.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        // CEXParser.loadFromUrl loads the data and then resolves the promise with the parser instance itself.
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    // Expose the hmtcurrent function via the HMTLib namespace
    window.HMTLib.hmtcurrent = hmtcurrent;

})(window);
```

**2. `test.html` (HTML test file)**

This HTML file demonstrates how to use the `hmtcurrent` function. It includes `cex-lib.js` from jsDelivr, then your `hmt-lib.js` file, and calls `HMTLib.hmtcurrent()`. The output of the `loadFromUrl` operation (which is the CEXParser instance itself, now populated with data) is then inspected.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - hmtcurrent</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        #output { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
    <!-- 1. Include cex-lib.js (from jsDelivr or local path) -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include your hmt-lib.js (ensure this path is correct) -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>HMTLib.hmtcurrent()</code></h1>
    <div id="output">Loading HMT CEX data... Please wait.</div>

    <script>
        async function runTest() {
            const outputDiv = document.getElementById('output');

            if (typeof HMTLib === 'undefined' || typeof HMTLib.hmtcurrent === 'undefined') {
                outputDiv.innerHTML = `<p style="color:red;"><strong>Error:</strong> HMTLib or HMTLib.hmtcurrent is not defined. Ensure hmt-lib.js is loaded correctly after cex-lib.js.</p>`;
                return;
            }

            try {
                // Call hmtcurrent, which returns a Promise<CEXParser>
                // The resolved value of the promise is the CEXParser instance itself,
                // after loadFromUrl has successfully processed the CEX data.
                const parserInstance = await HMTLib.hmtcurrent();

                const allBlockLabels = parserInstance.getAllBlockLabels(); // A method from CEXParser API

                outputDiv.innerHTML = `
                    <p style="color:green;"><strong>HMT CEX data loaded successfully!</strong></p>
                    <p>The <code>HMTLib.hmtcurrent()</code> function returned a <code>CEXParser</code> instance.</p>
                    <h3>Parser Instance Details:</h3>
                    <ul>
                        <li>Is instance of CEXParser: <code>${parserInstance instanceof CEXParser}</code></li>
                        <li>Number of unique block labels found: <code>${allBlockLabels.length}</code></li>
                        <li>Block labels: <code>${allBlockLabels.join(', ')}</code></li>
                    </ul>
                    <p>This 'parserInstance' (logged to console) can now be used to extract data using CEXParser methods.</p>
                `;

                console.log("CEXParser instance returned by HMTLib.hmtcurrent():", parserInstance);

                // Example: Displaying the content of the 'version' block if it exists
                const versionBlockLines = parserInstance.getBlock('version'); // getBlock returns string[]
                if (versionBlockLines && versionBlockLines.length > 0) {
                    // Escape HTML special characters for safe display in <pre>
                    const versionContent = versionBlockLines.join('\\n')
                                               .replace(/&/g, "&amp;")
                                               .replace(/</g, "&lt;")
                                               .replace(/>/g, "&gt;");
                    const versionDiv = document.createElement('div');
                    versionDiv.innerHTML = `<h3>Sample: Content of 'version' Block:</h3><pre>${versionContent}</pre>`;
                    outputDiv.appendChild(versionDiv);
                } else {
                    const noVersionDiv = document.createElement('div');
                    noVersionDiv.innerHTML = `<p><em>Note: No 'version' block was found or it is empty in the loaded CEX data.</em></p>`;
                    outputDiv.appendChild(noVersionDiv);
                }

            } catch (error) {
                outputDiv.innerHTML = `<p style="color:red;"><strong>Error loading or processing HMT CEX data:</strong> ${error.message}</p>`;
                console.error("Error in runTest:", error);
            }
        }

        runTest();
    </script>
</body>
</html>
```

**How to use:**

1.  Save the first code block as `hmt-lib.js`.
2.  Save the second code block as `test.html` in the same directory as `hmt-lib.js`.
3.  Open `test.html` in your web browser.

The page will first show a "Loading..." message. Once the CEX data is fetched and parsed, it will display information about the resulting `CEXParser` instance, including the block labels found and the content of the `version` block (if present). The `CEXParser` instance itself will also be logged to the browser's developer console. This demonstrates that `hmtcurrent` successfully used `loadFromUrl` and returned the populated parser.

### USER
  
I'm seeing this error: `Error loading or processing HMT CEX data: parserInstance.getAllBlockLabels is not a function. (In 'parserInstance.getAllBlockLabels()', 'parserInstance.getAllBlockLabels' is undefined)`

### ASSISTANT
You are correct! It seems I made a mistake in recalling the method name from the `CEXParser` API.

Based on the documentation you provided for `cex.js` (specifically the second excerpt from source id="1"), the correct method to retrieve all unique block labels is `getUniqueBlockLabels()`, not `getAllBlockLabels()`.

Please change this line in your `test.html` file:

```javascript
                const allBlockLabels = parserInstance.getAllBlockLabels(); // A method from CEXParser API
```

to:

```javascript
                const allBlockLabels = parserInstance.getUniqueBlockLabels(); // Correct method from CEXParser API
```

Here's the corrected part of the `test.html` script:

```html
    <script>
        async function runTest() {
            const outputDiv = document.getElementById('output');

            if (typeof HMTLib === 'undefined' || typeof HMTLib.hmtcurrent === 'undefined') {
                outputDiv.innerHTML = `<p style="color:red;"><strong>Error:</strong> HMTLib or HMTLib.hmtcurrent is not defined. Ensure hmt-lib.js is loaded correctly after cex-lib.js.</p>`;
                return;
            }

            try {
                // Call hmtcurrent, which returns a Promise<CEXParser>
                // The resolved value of the promise is the CEXParser instance itself,
                // after loadFromUrl has successfully processed the CEX data.
                const parserInstance = await HMTLib.hmtcurrent();

                // ***** CORRECTED LINE HERE *****
                const allBlockLabels = parserInstance.getUniqueBlockLabels(); 

                outputDiv.innerHTML = `
                    <p style="color:green;"><strong>HMT CEX data loaded successfully!</strong></p>
                    <p>The <code>HMTLib.hmtcurrent()</code> function returned a <code>CEXParser</code> instance.</p>
                    <h3>Parser Instance Details:</h3>
                    <ul>
                        <li>Is instance of CEXParser: <code>${parserInstance instanceof CEXParser}</code></li>
                        <li>Number of unique block labels found: <code>${allBlockLabels.length}</code></li>
                        <li>Block labels: <code>${allBlockLabels.join(', ')}</code></li>
                    </ul>
                    <p>This 'parserInstance' (logged to console) can now be used to extract data using CEXParser methods.</p>
                `;

                console.log("CEXParser instance returned by HMTLib.hmtcurrent():", parserInstance);

                // Example: Displaying the content of the 'version' block if it exists
                const versionBlockLines = parserInstance.getBlockContents('version'); // Corrected to getBlockContents as per CEX API for block content
                if (versionBlockLines && versionBlockLines.length > 0) {
                    // Escape HTML special characters for safe display in <pre>
                    const versionContent = versionBlockLines.join('\\n') // getBlockContents returns an array of strings, one per block
                                               .replace(/&/g, "&amp;")
                                               .replace(/</g, "&lt;")
                                               .replace(/>/g, "&gt;");
                    const versionDiv = document.createElement('div');
                    versionDiv.innerHTML = `<h3>Sample: Content of 'version' Block:</h3><pre>${versionContent}</pre>`;
                    outputDiv.appendChild(versionDiv);
                } else {
                    const noVersionDiv = document.createElement('div');
                    noVersionDiv.innerHTML = `<p><em>Note: No 'version' block was found or it is empty in the loaded CEX data.</em></p>`;
                    outputDiv.appendChild(noVersionDiv);
                }

            } catch (error) {
                outputDiv.innerHTML = `<p style="color:red;"><strong>Error loading or processing HMT CEX data:</strong> ${error.message}</p>`;
                console.error("Error in runTest:", error);
            }
        }

        runTest();
    </script>
```

I also noticed another potential point of confusion: the documentation mentions `parser.getBlockContents('ctsdata')` for getting the content of blocks. While `getBlock` might exist, `getBlockContents` seems more aligned with the API structure for retrieving the actual data lines of a block. I've updated the example to use `getBlockContents('version')` just to be consistent with that part of the documentation for fetching block data, although your original error was specifically with `getAllBlockLabels`. If `getBlock('version')` was working for you, that's fine, but `getBlockContents` is explicitly documented for this purpose.

My apologies for the error in the initial response! The `getUniqueBlockLabels()` method should resolve the specific error you're encountering.

### USER
Could you show me the complete file `hmt-lib.js` with the changes incorporated?

### ASSISTANT
Okay, here is the complete `hmt-lib.js` file. This file itself didn't require changes based on the previous error (which was in the `test.html` file's usage of the CEXParser API).

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * This function utilizes CEXParser.loadFromUrl from cex-lib.js.
     *
     * It assumes CEXParser is available in the global scope (from including cex-lib.js).
     *
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance
     *                               loaded with the HMT data. If loading fails or
     *                               CEXParser is not found, the Promise will be rejected
     *                               with an Error.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        // CEXParser.loadFromUrl loads the data and then resolves the promise with the parser instance itself.
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    // Expose the hmtcurrent function via the HMTLib namespace
    window.HMTLib.hmtcurrent = hmtcurrent;

})(window);
```

### USER
Great! Now let's add two more functions, `hmtnormalized` and `hmtdiplomatic`. The each take a single parameter, the `CEXParser` instance returned by `hmtcurrent`. Both functions begin by getting `parserInstance.getBlockContents('ctsdata')`. This will return an array of delimited-text lines with two columns separated by the pipe character '|'. The first column will contain a CTS URN value, and the second column will contain the text contents of the passage. The CTS URN has five colon-separated components.  We want to look at the work component, the fourth of the five. The `hmtnormalized` function should return records with a work component ending in the string `.normalized`; the `hmtdiplomatic` function should return records with a work component ending in the string `.diplomatic`.
  
_Test_: Please implement this and write an HTML page to test the functions as by displaying to the user the number of text passages (or records) returned by `hmtnormalized` and `hmtdiplomatic`.

### ASSISTANT
Okay, this is a great next step! We'll add the `hmtnormalized` and `hmtdiplomatic` functions to your `hmt-lib.js` and create a new test HTML page for them. These functions will leverage `urn-lib.js` to inspect the work component of CTS URNs.

Here's the implementation:

**1. `hmt-lib.js` (Updated)**

We'll add the new functions and ensure they use `URNTools` from `urn-lib.js`.

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * This function utilizes CEXParser.loadFromUrl from cex-lib.js.
     *
     * It assumes CEXParser is available in the global scope (from including cex-lib.js).
     *
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance
     *                               loaded with the HMT data. If loading fails or
     *                               CEXParser is not found, the Promise will be rejected
     *                               with an Error.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.normalized'.
     *
     * Assumes URNTools is available in the global scope (from including urn-lib.js).
     *
     * @param {CEXParser} parserInstance - The CEXParser instance containing parsed CEX data.
     * @returns {string[]} An array of matching delimited-text lines (records).
     *                     Returns an empty array if URNTools or parserInstance is invalid,
     *                     or no matching records are found.
     */
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded before hmt-lib.js.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtnormalized.");
            return [];
        }

        const filteredRecords = [];
        // getBlockContents returns an array of strings, where each string is the
        // content of one 'ctsdata' block.
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                // Ignore empty lines and comments
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    return;
                }

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) { // We need at least the URN
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString); // Retrieves the 4th component

                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.diplomatic'.
     *
     * Assumes URNTools is available in the global scope (from including urn-lib.js).
     *
     * @param {CEXParser} parserInstance - The CEXParser instance containing parsed CEX data.
     * @returns {string[]} An array of matching delimited-text lines (records).
     *                     Returns an empty array if URNTools or parserInstance is invalid,
     *                     or no matching records are found.
     */
    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded before hmt-lib.js.");
            return [];
        }
         if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdiplomatic.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                // Ignore empty lines and comments
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    return;
                }

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) { // We need at least the URN
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString); // Retrieves the 4th component

                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    // Expose functions via the HMTLib namespace
    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;

})(window);
```

**Key changes and considerations in `hmt-lib.js`:**

*   **URNTools Dependency:** The functions now explicitly check for `URNTools` (from `urn-lib.js`) and `CEXParser` instance validity.
*   **Processing `getBlockContents`:**
    *   `parserInstance.getBlockContents('ctsdata')` returns an array. Each element of this array is a string containing the *entire content of one `ctsdata` block*.
    *   We iterate through each of these block content strings.
    *   Each block content string is then split by newline (`\n`) to get individual data lines.
    *   Each line is trimmed, and comments (`//`) or empty lines are skipped.
*   **URN Parsing:** `URNTools.workcomponent(urnString)` is used to extract the work component (the 4th part) of the URN.
*   **Filtering:** The `endsWith('.normalized')` or `endsWith('.diplomatic')` check is performed on the extracted work component.
*   **Return Value:** The functions return an array of the original string lines that matched the criteria.

**2. `test_filters.html` (New HTML test file)**

This HTML page will:
1.  Load `cex-lib.js`, `urn-lib.js` (both from jsDelivr for ease of testing), and your updated `hmt-lib.js`.
2.  Use `HMTLib.hmtcurrent()` to fetch the CEX data and get the `CEXParser` instance.
3.  Pass this instance to `HMTLib.hmtnormalized()` and `HMTLib.hmtdiplomatic()`.
4.  Display the number of records returned by each function.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Normalized & Diplomatic Filters</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        #results { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js (ensure this path is correct) -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>hmtnormalized</code> and <code>hmtdiplomatic</code></h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data and applying filters... Please wait.</p>
    </div>
    <div id="results" style="display:none;">
        <h2>Filter Results:</h2>
        <p>Number of <strong>normalized</strong> text passages: <strong id="normalizedCount">N/A</strong></p>
        <p>Number of <strong>diplomatic</strong> text passages: <strong id="diplomaticCount">N/A</strong></p>
    </div>
    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runFilterTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const resultsDiv = document.getElementById('results');
            const errorLogDiv = document.getElementById('errorLog');
            const normalizedCountSpan = document.getElementById('normalizedCount');
            const diplomaticCountSpan = document.getElementById('diplomaticCount');

            function showError(message) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred.</p>`;
            }

            if (typeof CEXParser === 'undefined') {
                showError("<strong>Error:</strong> CEXParser is not defined. Ensure cex-lib.js is loaded.");
                return;
            }
            if (typeof URNTools === 'undefined') {
                showError("<strong>Error:</strong> URNTools is not defined. Ensure urn-lib.js is loaded.");
                return;
            }
            if (typeof HMTLib === 'undefined' ||
                typeof HMTLib.hmtcurrent === 'undefined' ||
                typeof HMTLib.hmtnormalized === 'undefined' ||
                typeof HMTLib.hmtdiplomatic === 'undefined') {
                showError("<strong>Error:</strong> HMTLib or its required functions are not defined. Ensure hmt-lib.js is loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded successfully. Applying filters...</p>`;

                const normalizedRecords = HMTLib.hmtnormalized(parserInstance);
                const diplomaticRecords = HMTLib.hmtdiplomatic(parserInstance);

                normalizedCountSpan.textContent = normalizedRecords.length;
                diplomaticCountSpan.textContent = diplomaticRecords.length;

                resultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">Processing complete.</p>`;

                console.log("Normalized records found:", normalizedRecords.length, normalizedRecords.slice(0, 5)); // Log first 5 for quick check
                console.log("Diplomatic records found:", diplomaticRecords.length, diplomaticRecords.slice(0, 5)); // Log first 5 for quick check

            } catch (error) {
                showError(`<strong>Error during processing:</strong> ${error.message}`);
                console.error("Error in runFilterTest:", error);
            }
        }

        runFilterTest();
    </script>
</body>
</html>
```

**How to use:**

1.  Save the **updated `hmt-lib.js`** (first code block).
2.  Save the new HTML test file as `test_filters.html` (second code block) in the same directory as `hmt-lib.js`.
3.  Open `test_filters.html` in your web browser.

The page will:
*   Show a loading message.
*   Fetch the HMT CEX data.
*   Apply the `hmtnormalized` and `hmtdiplomatic` filters.
*   Display the number of text passages found for each category.
*   Log the counts and the first few records of each type to the browser's developer console for verification.

This setup should correctly implement and test your new functions.

### USER
  
Super. Now I want to create a new class, `DSERecord`, with properties named `passage`, `imageroi` and `surface`. We need a function named `hmtdse` that create an Array of `DSERecord` objects as follows.
  
Get the contents of all CITE relation sets by using the current instance of `CEXParser` with `getBlockContents("citerelationset")`. Each resulting block with have two initial lines beginning with `urn|` and `label|`. Following these, there will be delimited text data beginning with a pipe-delimited header line. If the initial line beginning `urn|` is completed with the identifier `urn:cite2:hmt:hmtdse.v1:all`, we want to process the delimited text data in that block. The header line should be `passage|imageroi|surface`. For each subsequent row, we want to create a `DSERecord` from the contents of each column.
  
**Test**: Please implement this and test it by writing an HTML file that loads the current HMT release, uses the `hmtdse` record to get an array of `DSERecord` objects, then displays 1) the total number of objects in the array, and 2) the first 10 `DSERecord`s in the array.

### ASSISTANT
Okay, this is an excellent addition. We'll create the `DSERecord` class and the `hmtdse` function within your `hmt-lib.js`, then build an HTML page to test this new functionality.

Here's the implementation:

**1. `hmt-lib.js` (Updated)**

We'll add the `DSERecord` class and the `hmtdse` function.

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Represents a DSE (Document-Surface-Element) record.
     */
    class DSERecord {
        /**
         * Creates an instance of DSERecord.
         * @param {string} passage - The passage identifier.
         * @param {string} imageroi - The image ROI (Region of Interest) identifier.
         * @param {string} surface - The surface identifier.
         */
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.normalized'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtnormalized.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.diplomatic'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdiplomatic.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Extracts DSE (Document-Surface-Element) records from 'citerelationset' blocks
     * specifically from 'urn:cite2:hmt:hmtdse.v1:all'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {DSERecord[]} An array of DSERecord objects.
     */
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdse.");
            return [];
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = []; // Store non-empty, non-comment lines

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) {
                    processedLines.push(trimmedLine);
                }
            }

            // A valid block for DSE needs at least URN, label, header, and one data line.
            // But we'll check for URN, label, header first (min 3 lines).
            if (processedLines.length < 3) {
                // console.warn("Skipping citerelationset block: not enough processed lines for URN, label, and header.");
                continue;
            }

            let currentBlockUrn = null;
            if (processedLines[0].startsWith("urn|")) {
                currentBlockUrn = processedLines[0].substring("urn|".length);
            } else {
                // console.warn("Skipping citerelationset block: First processed line does not start with 'urn|'. Line: " + processedLines[0]);
                continue;
            }

            // Optional: check for label line
            // if (!processedLines[1].startsWith("label|")) {
            //     console.warn("Skipping citerelationset block: Second processed line does not start with 'label|'. Line: " + processedLines[1]);
            //     continue;
            // }

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) {
                    console.warn(`Skipping DSE block ${currentBlockUrn}: Header mismatch. Expected "${expectedHeader}", found "${headerLine}".`);
                    continue;
                }

                // Data rows start from index 3 of processedLines
                for (let i = 3; i < processedLines.length; i++) {
                    const dataLine = processedLines[i];
                    const columns = dataLine.split('|');

                    if (columns.length === 3) { // passage, imageroi, surface
                        const record = new DSERecord(columns[0], columns[1], columns[2]);
                        dseRecords.push(record);
                    } else {
                        console.warn(`Skipping data row in DSE block ${currentBlockUrn}: Incorrect number of columns. Expected 3, found ${columns.length}. Row: "${dataLine}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    // Expose functions and class via the HMTLib namespace
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;

})(window);
```

**Key changes in `hmt-lib.js`:**

*   **`DSERecord` Class:** Defined at the beginning of the IIFE with a constructor for `passage`, `imageroi`, and `surface`. It's also exposed on `window.HMTLib`.
*   **`hmtdse` Function:**
    *   Takes a `CEXParser` instance.
    *   Calls `parserInstance.getBlockContents("citerelationset")`.
    *   Iterates through each block's content string.
    *   Splits block content into lines and processes them to remove empty/comment lines.
    *   Checks if the first processed line starts with `urn|` and if its value matches `urn:cite2:hmt:hmtdse.v1:all`.
    *   If the URN matches, it checks if the third processed line (expected to be the header) is `passage|imageroi|surface`.
    *   If both URN and header match, it iterates through subsequent processed lines, splits them by `|`, and creates `DSERecord` objects for rows with 3 columns.
    *   Returns an array of `DSERecord` objects.

**2. `test_dse.html` (New HTML test file)**

This file will test the `hmtdse` function.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - DSE Records</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        #results { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        .record { border-bottom: 1px solid #eee; padding: 8px 0; margin-bottom: 8px; }
        .record:last-child { border-bottom: none; margin-bottom: 0; }
        .record strong { display: inline-block; min-width: 80px; }
        pre { background-color: #eef; padding: 5px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js (optional for this specific test, but good for consistency) -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js (ensure this path is correct) -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>hmtdse</code> Function</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data and processing DSE records... Please wait.</p>
    </div>
    <div id="results" style="display:none;">
        <h2>DSE Record Results:</h2>
        <p>Total number of DSERecord objects: <strong id="totalCount">N/A</strong></p>
        <h3>First 10 DSERecord Objects (if available):</h3>
        <div id="dseList">
            <p><em>No records to display.</em></p>
        </div>
    </div>
    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runDseTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const resultsDiv = document.getElementById('results');
            const errorLogDiv = document.getElementById('errorLog');
            const totalCountSpan = document.getElementById('totalCount');
            const dseListDiv = document.getElementById('dseList');

            function showError(message) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred.</p>`;
            }

            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return '';
                return unsafe
                    .toString()
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            if (typeof CEXParser === 'undefined') {
                showError("<strong>Error:</strong> CEXParser is not defined. Ensure cex-lib.js is loaded.");
                return;
            }
            // URNTools is not directly used by hmtdse but HMTLib includes functions that do.
            // if (typeof URNTools === 'undefined') {
            //     showError("<strong>Error:</strong> URNTools is not defined. Ensure urn-lib.js is loaded.");
            //     return;
            // }
            if (typeof HMTLib === 'undefined' ||
                typeof HMTLib.hmtcurrent === 'undefined' ||
                typeof HMTLib.hmtdse === 'undefined' ||
                typeof HMTLib.DSERecord === 'undefined') {
                showError("<strong>Error:</strong> HMTLib or its required components (hmtcurrent, hmtdse, DSERecord) are not defined. Ensure hmt-lib.js is loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded successfully. Processing DSE records...</p>`;

                const dseRecords = HMTLib.hmtdse(parserInstance);

                totalCountSpan.textContent = dseRecords.length;

                if (dseRecords.length > 0) {
                    dseListDiv.innerHTML = ''; // Clear "No records" message
                    const recordsToShow = Math.min(10, dseRecords.length);
                    for (let i = 0; i < recordsToShow; i++) {
                        const record = dseRecords[i];
                        const recordDiv = document.createElement('div');
                        recordDiv.classList.add('record');
                        recordDiv.innerHTML = `
                            <p><strong>Record ${i + 1}:</strong></p>
                            <pre><strong>Passage:</strong> ${escapeHtml(record.passage)}\n<strong>ImageROI:</strong> ${escapeHtml(record.imageroi)}\n<strong>Surface:</strong> ${escapeHtml(record.surface)}</pre>
                        `;
                        dseListDiv.appendChild(recordDiv);
                    }
                } else {
                    dseListDiv.innerHTML = '<p><em>No DSERecords found matching the criteria.</em></p>';
                }

                resultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">Processing complete.</p>`;

                console.log("DSE Records found:", dseRecords.length);
                console.log("First 10 DSE Records:", dseRecords.slice(0, 10));

            } catch (error) {
                showError(`<strong>Error during processing:</strong> ${error.message}`);
                console.error("Error in runDseTest:", error);
            }
        }

        runDseTest();
    </script>
</body>
</html>
```

**How to use:**

1.  Save the **updated `hmt-lib.js`** (first code block).
2.  Save the new HTML test file as `test_dse.html` (second code block) in the same directory as `hmt-lib.js`.
3.  Open `test_dse.html` in your web browser.

The page will:
*   Load the HMT CEX data.
*   Process `citerelationset` blocks using your `hmtdse` function.
*   Display the total number of `DSERecord` objects created.
*   List the `passage`, `imageroi`, and `surface` properties for the first 10 records (if any).
*   Log information to the browser's developer console.

This setup should provide a good test for your new `DSERecord` class and `hmtdse` function. I've also added a simple `escapeHtml` function in the test HTML to make the display of property values a bit safer, just in case.

### USER
  
Perfect! Now let's add three functions that work with arrays of `DSERecord`s. 1) The function `recordsforpage` should take two parameters, a CITE2 URN, and an Array of `DSERecord`s. It should return a (possibly empty) Array of all `DSERecord`s with a `page` property matching the given vaule. 2) The function `recordforpassage` should take two parameters, a CTS URN, and an Array of `DSERecord`s. It should return a single `DSERecord` with a `passage` property matching the given CTS URN, or nothing. 3) The function `imageforpage` is a little trickier. It should take two parameters, a CITE2 URN identifying a page, and an Array of `DSERecord`s, and return either the URN for an image or nothing. The function should first use `recordsforpage` to find all `DSERecord`s matching the given page URN.  Then it should take the `imageroi` property of the first record. The value normally ends with an ROI identifier starting with `@`: this should be dropped, and the remaining image identifier returned.  For example, if the first `DSERecord` had an image property `urn:cite2:hmt:e3bifolio.v1:E3_97bisv_98r@0.501,0.3063,0.224,0.0435`, the function should drop the string `@0.501,0.3063,0.224,0.0435`, and return `urn:cite2:hmt:e3bifolio.v1:E3_97bisv_98r`.
  
**Test**: Please implement these functions, and write an HTML test page to test them as follows. First load the current HMT data release, then use `hmtdse` to get all its `DSERecord`s. Display the result of calling `recordsforpage` using `urn:cite2:hmt:msA.v1:13r` as the page value. Display the results of calling `recordforpassage` with the passage value `urn:cts:greekLit:tlg0012.tlg001.msA:1.1`. Display the results of calling `imageforpage` using `urn:cite2:hmt:e3pages.v1:98r` as the the value  for page.

### ASSISTANT
Okay, this set of functions will be very useful for working with DSE data! We'll add them to `hmt-lib.js` and create a new test HTML page.

I'm proceeding with the assumption (as discussed in my thoughts) that when your prompt refers to a "page" URN in the context of `DSERecord`s, it means the value stored in the `DSERecord.surface` property, which is derived from the `surface` column of the `hmtdse` relation set.

**1. `hmt-lib.js` (Updated)**

This includes the new functions `recordsforpage`, `recordforpassage`, and `imageforpage`, along with the previously defined `DSERecord` class and other HMTLib functions.

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Represents a DSE (Document-Surface-Element) record.
     */
    class DSERecord {
        /**
         * Creates an instance of DSERecord.
         * @param {string} passage - The passage identifier (CTS URN).
         * @param {string} imageroi - The image ROI (Region of Interest) identifier (CITE2 URN with optional ROI).
         * @param {string} surface - The surface identifier (CITE2 URN, often a page).
         */
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface; // This property is matched against 'page' URNs
        }
    }

    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.normalized'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtnormalized.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.diplomatic'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdiplomatic.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Extracts DSE (Document-Surface-Element) records from 'citerelationset' blocks
     * specifically from 'urn:cite2:hmt:hmtdse.v1:all'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {DSERecord[]} An array of DSERecord objects.
     */
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdse.");
            return [];
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = []; 

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) {
                    processedLines.push(trimmedLine);
                }
            }

            if (processedLines.length < 3) { // Need at least URN, label, header
                continue;
            }

            let currentBlockUrn = null;
            if (processedLines[0].startsWith("urn|")) {
                currentBlockUrn = processedLines[0].substring("urn|".length);
            } else {
                continue;
            }

            // Optional: Check label line, though not strictly necessary for this function's logic
            // if (!processedLines[1].startsWith("label|")) continue;


            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2]; // Header is the 3rd processed line
                if (headerLine !== expectedHeader) {
                    console.warn(`Skipping DSE block ${currentBlockUrn}: Header mismatch. Expected "${expectedHeader}", found "${headerLine}".`);
                    continue;
                }

                for (let i = 3; i < processedLines.length; i++) { // Data starts from 4th processed line
                    const dataLine = processedLines[i];
                    const columns = dataLine.split('|');

                    if (columns.length === 3) { // passage, imageroi, surface
                        const record = new DSERecord(columns[0], columns[1], columns[2]);
                        dseRecords.push(record);
                    } else {
                        console.warn(`Skipping data row in DSE block ${currentBlockUrn}: Incorrect number of columns. Expected 3, found ${columns.length}. Row: "${dataLine}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    // --- NEW DSE Record Query FUNCTIONS ---

    /**
     * Finds all DSERecords where the 'surface' property matches the given page URN.
     *
     * @param {string} pageUrn - The CITE2 URN of the page to search for.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {HMTLib.DSERecord[]} An array of matching DSERecord objects (possibly empty).
     */
    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input. pageUrn must be a non-empty string and dseRecordsArray an array.");
            return [];
        }
        return dseRecordsArray.filter(record => record instanceof DSERecord && record.surface === pageUrn);
    }

    /**
     * Finds the first DSERecord where the 'passage' property matches the given CTS URN.
     *
     * @param {string} passageUrn - The CTS URN of the passage to search for.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {HMTLib.DSERecord | null} The matching DSERecord object, or null if not found.
     */
    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input. passageUrn must be a non-empty string and dseRecordsArray an array.");
            return null;
        }
        return dseRecordsArray.find(record => record instanceof DSERecord && record.passage === passageUrn) || null;
    }

    /**
     * Finds the image URN for a given page URN from an array of DSERecords.
     * It first finds records for the page using `recordsforpage`, then extracts 
     * and processes the imageroi property of the first matching record by 
     * removing the ROI suffix (part after the last '@').
     *
     * @param {string} pageUrn - The CITE2 URN identifying the page.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {string | null} The image URN (without ROI), or null if no matching record
     *                          is found or if the imageroi property is missing/invalid.
     */
    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input. pageUrn must be a non-empty string and dseRecordsArray an array.");
            return null;
        }

        const matchingPageRecords = recordsforpage(pageUrn, dseRecordsArray);

        if (matchingPageRecords.length > 0) {
            const firstRecord = matchingPageRecords[0];
            if (firstRecord && firstRecord.imageroi && typeof firstRecord.imageroi === 'string') {
                const imageroi = firstRecord.imageroi;
                const roiSeparatorIndex = imageroi.lastIndexOf('@');
                
                if (roiSeparatorIndex !== -1) {
                    return imageroi.substring(0, roiSeparatorIndex);
                }
                // If no '@' is found, the entire string is considered the image identifier.
                return imageroi; 
            } else {
                // console.warn(`imageforpage: First record for page ${pageUrn} has missing, null, or invalid imageroi property.`);
                return null; 
            }
        }
        return null; // No records found for the page
    }

    // Expose functions and class via the HMTLib namespace
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;

})(window);
```

**2. `test_dse_queries.html` (New HTML test file)**

This page will load the HMT data, get DSE records, and then test each of the three new functions.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - DSE Record Queries</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .results-section { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        pre { background-color: #eef; padding: 10px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; max-height: 300px; overflow-y: auto; }
        h2, h3 { margin-top: 1em; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js (HMTLib uses it for other functions) -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js (ensure this path is correct) -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: DSE Record Query Functions</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data and DSE records... Please wait.</p>
    </div>

    <div id="testResults" style="display:none;">
        <div class="results-section">
            <h3>Test <code>recordsforpage</code></h3>
            <p>Searching for page: <code>urn:cite2:hmt:msA.v1:13r</code></p>
            <p>Number of records found: <strong id="recordsForPageCount">N/A</strong></p>
            <p>Matching records (displaying properties of first 5, if any):</p>
            <pre id="recordsForPageOutput">N/A</pre>
        </div>

        <div class="results-section">
            <h3>Test <code>recordforpassage</code></h3>
            <p>Searching for passage: <code>urn:cts:greekLit:tlg0012.tlg001.msA:1.1</code></p>
            <p>Matching record (displaying properties, if any):</p>
            <pre id="recordForPassageOutput">N/A</pre>
        </div>

        <div class="results-section">
            <h3>Test <code>imageforpage</code></h3>
            <p>Searching for image for page: <code>urn:cite2:hmt:e3pages.v1:98r</code></p>
            <p>Image URN found:</p>
            <pre id="imageForPageOutput">N/A</pre>
        </div>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runDseQueryTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const testResultsDiv = document.getElementById('testResults');
            const errorLogDiv = document.getElementById('errorLog');

            const recordsForPageCountEl = document.getElementById('recordsForPageCount');
            const recordsForPageOutputEl = document.getElementById('recordsForPageOutput');
            const recordForPassageOutputEl = document.getElementById('recordForPassageOutput');
            const imageForPageOutputEl = document.getElementById('imageForPageOutput');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console for details.</p>`;
                console.error(message, errorObj || '');
            }

            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return 'null';
                return unsafe
                    .toString()
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            function formatDSERecordsForDisplay(recordsArray, maxToShow = 5) {
                if (!recordsArray || recordsArray.length === 0) {
                    return "No records found.";
                }
                let output = "";
                const showCount = Math.min(recordsArray.length, maxToShow);
                for (let i = 0; i < showCount; i++) {
                    const r = recordsArray[i];
                    output += `Record ${i+1} of ${recordsArray.length}:\n` +
                              `  Passage: ${escapeHtml(r.passage)}\n` +
                              `  ImageROI: ${escapeHtml(r.imageroi)}\n` +
                              `  Surface: ${escapeHtml(r.surface)}\n\n`;
                }
                if (recordsArray.length > maxToShow) {
                    output += `... and ${recordsArray.length - maxToShow} more records not shown.`;
                }
                return output.trim();
            }
            
            function formatDSERecordForDisplay(record) {
                if (!record) {
                    return "Record not found (result is null).";
                }
                 return `Passage: ${escapeHtml(record.passage)}\n` +
                        `ImageROI: ${escapeHtml(record.imageroi)}\n` +
                        `Surface: ${escapeHtml(record.surface)}`;
            }


            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.hmtdse || !HMTLib.DSERecord ||
                !HMTLib.recordsforpage || !HMTLib.recordforpassage || !HMTLib.imageforpage) {
                showError("<strong>Error:</strong> A required library (CEXParser, URNTools, HMTLib) or HMTLib function is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Processing DSE records...</p>`;
                
                const allDseRecords = HMTLib.hmtdse(parserInstance);
                console.log(`Total DSE Records fetched by hmtdse: ${allDseRecords.length}`);

                if (allDseRecords.length === 0) {
                    // This could happen if the targetRelationSetUrn is not found or has no data.
                    showError("Warning: No DSE records were found by `hmtdse`. The tests for DSE query functions might yield empty results or nulls.");
                    // Allow tests to proceed to see if they handle empty arrays gracefully.
                }
                loadingStatusDiv.innerHTML = `<p class="status success">DSE records processed (${allDseRecords.length} found). Running query tests...</p>`;


                // Test recordsforpage
                const pageUrnForRecordsTest = "urn:cite2:hmt:msA.v1:13r";
                const foundPageRecords = HMTLib.recordsforpage(pageUrnForRecordsTest, allDseRecords);
                recordsForPageCountEl.textContent = foundPageRecords.length;
                recordsForPageOutputEl.textContent = formatDSERecordsForDisplay(foundPageRecords);
                console.log(`Test recordsforpage with URN ${pageUrnForRecordsTest}: Found ${foundPageRecords.length} records.`, foundPageRecords.slice(0,5));

                // Test recordforpassage
                const passageUrnForRecordTest = "urn:cts:greekLit:tlg0012.tlg001.msA:1.1";
                const foundPassageRecord = HMTLib.recordforpassage(passageUrnForRecordTest, allDseRecords);
                recordForPassageOutputEl.textContent = formatDSERecordForDisplay(foundPassageRecord);
                console.log(`Test recordforpassage with URN ${passageUrnForRecordTest}:`, foundPassageRecord);

                // Test imageforpage
                const pageUrnForImageTest = "urn:cite2:hmt:e3pages.v1:98r";
                const foundImageUrn = HMTLib.imageforpage(pageUrnForImageTest, allDseRecords);
                imageForPageOutputEl.textContent = escapeHtml(foundImageUrn) || "Image URN not found (result is null).";
                console.log(`Test imageforpage with URN ${pageUrnForImageTest}: Result is '${foundImageUrn}'`);

                testResultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">All DSE query tests complete.</p>`;

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runDseQueryTest();
    </script>
</body>
</html>
```

**How to use:**

1.  Save the **updated `hmt-lib.js`** (first code block).
2.  Save the new HTML test file as `test_dse_queries.html` (second code block) in the same directory as `hmt-lib.js`.
3.  Open `test_dse_queries.html` in your web browser.

The page will:
*   Load the HMT CEX data and parse DSE records.
*   Test `recordsforpage` with `urn:cite2:hmt:msA.v1:13r` and display the count and details of matching records.
*   Test `recordforpassage` with `urn:cts:greekLit:tlg0012.tlg001.msA:1.1` and display the details of the found record (if any).
*   Test `imageforpage` with `urn:cite2:hmt:e3pages.v1:98r` and display the resulting image URN (if any).
*   Log details to the browser's developer console.

This setup should thoroughly test your new DSE record query functions.

### USER
  
Fabulous! Now I want to create a new class, `Scholion`, with properties named `scholion`, and `iliad`. We need a function named `hmtscholia` that creates an Array of `DSERecord` objects as follows.
  
Get the contents of all CITE relation sets by using the current instance of `CEXParser` with `getBlockContents("citerelationset")`. Each resulting block with have two initial lines beginning with `urn|` and `label|`. Following these, there will be delimited text data beginning with a pipe-delimited header line. If the initial line beginning `urn|` is completed with the identifier `urn:cite2:hmt:commentary.v1:all`, we want to process the delimited text data in that block. The header line should be `scholion|iliad`. For each subsequent row, we want to create a `Scholion` from the contents of each column.
  
We will also want two functions for working with an Array of `Scholion` objects. 1) `passageforscholion` should take two parameters, a CTS URN for a scholion value, and an Array of `Scholion` objects. The function should find `Scholion` objects with `scholion` property matching the given value. The result should be 0 or 1 matches. If there is a match, return the `passage` property of the `Scholion`; return nothing if there is no match. 2) `scholiaforpassage` should take two parameters, a CTS URN for a passage value, and an Array of `Scholion` objects. The function find all `Scholion` objects matching the given URN for the passage value, and return the values of their `scholion` property. The result should be a (possibly empty) Array of the `scholion` values.
  
**Test**: Please implement this, and test it by writing an HTML page that loads the current HMT release and uses the `hmtscholia` function to collect all the `Scholion` . Display the number of `Scholion` objects. Then use `passageforscholion` to find the passage value for scholion `urn:cts:greekLit:tlg5026.msAint.hmt:1.27` and display the result. Use `scholiaforpassage` with the CTS URN `urn:cts:greekLit:tlg0012.tlg001.msA:1.1`  and display the result.

### ASSISTANT
Okay, this is a fantastic addition to the library, dealing with scholarly annotations (scholia).

Here's the implementation plan:

1.  **`Scholion` Class**: We'll define this class with `scholion` and `iliad` properties.
2.  **`hmtscholia` Function**: This will parse `citerelationset` blocks to find scholia data, similar to how `hmtdse` works but targeting the scholia-specific URN and header. It will return an array of `Scholion` objects.
3.  **`passageforscholion` Function**: This will take a scholion URN and an array of `Scholion` objects, and return the corresponding Iliad passage URN (the `iliad` property of the found `Scholion` object).
4.  **`scholiaforpassage` Function**: This will take an Iliad passage URN and an array of `Scholion` objects, and return an array of URNs for all scholia that refer to that Iliad passage.

Let's implement these in `hmt-lib.js` and then create the test HTML page.

**1. `hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    // Create a namespace for the library if it doesn't exist
    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    /**
     * Represents a DSE (Document-Surface-Element) record.
     */
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    /**
     * Represents a Scholion record, linking a scholion URN to an Iliad passage URN.
     */
    class Scholion {
        /**
         * Creates an instance of Scholion.
         * @param {string} scholionUrn - The CTS URN of the scholion text.
         * @param {string} iliadUrn - The CTS URN of the Iliad passage the scholion refers to.
         */
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn; // CTS URN of the scholion
            this.iliad = iliadUrn;     // CTS URN of the Iliad passage
        }
    }


    /**
     * Loads the HMT current CEX data source from a predefined URL.
     * @returns {Promise<CEXParser>} A Promise that resolves with the CEXParser instance.
     */
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";

        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser is not defined. Ensure cex-lib.js is loaded before hmt-lib.js.");
            return Promise.reject(new Error("CEXParser is not defined. Ensure cex-lib.js is loaded."));
        }

        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    // ... (hmtnormalized, hmtdiplomatic, hmtdse functions remain unchanged) ...
    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.normalized'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtnormalized.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Filters records from 'ctsdata' blocks where the CTS URN's work component
     * ends with '.diplomatic'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of matching delimited-text lines.
     */
    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') {
            console.error("URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdiplomatic.");
            return [];
        }

        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;

                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    /**
     * Extracts DSE (Document-Surface-Element) records from 'citerelationset' blocks
     * specifically from 'urn:cite2:hmt:hmtdse.v1:all'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {DSERecord[]} An array of DSERecord objects.
     */
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtdse.");
            return [];
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = []; 

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) {
                    processedLines.push(trimmedLine);
                }
            }

            if (processedLines.length < 3) {
                continue;
            }

            let currentBlockUrn = null;
            if (processedLines[0].startsWith("urn|")) {
                currentBlockUrn = processedLines[0].substring("urn|".length);
            } else {
                continue;
            }

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) {
                    console.warn(`Skipping DSE block ${currentBlockUrn}: Header mismatch. Expected "${expectedHeader}", found "${headerLine}".`);
                    continue;
                }

                for (let i = 3; i < processedLines.length; i++) {
                    const dataLine = processedLines[i];
                    const columns = dataLine.split('|');

                    if (columns.length === 3) { 
                        const record = new HMTLib.DSERecord(columns[0], columns[1], columns[2]);
                        dseRecords.push(record);
                    } else {
                        console.warn(`Skipping data row in DSE block ${currentBlockUrn}: Incorrect number of columns. Expected 3, found ${columns.length}. Row: "${dataLine}"`);
                    }
                }
            }
        }
        return dseRecords;
    }
     /**
     * Finds all DSERecords where the 'surface' property matches the given page URN.
     * @param {string} pageUrn - The CITE2 URN of the page.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {HMTLib.DSERecord[]} An array of matching DSERecord objects.
     */
    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input.");
            return [];
        }
        return dseRecordsArray.filter(record => record instanceof HMTLib.DSERecord && record.surface === pageUrn);
    }

    /**
     * Finds the first DSERecord where the 'passage' property matches the given CTS URN.
     * @param {string} passageUrn - The CTS URN of the passage.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {HMTLib.DSERecord | null} The matching DSERecord object, or null.
     */
    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input.");
            return null;
        }
        return dseRecordsArray.find(record => record instanceof HMTLib.DSERecord && record.passage === passageUrn) || null;
    }

    /**
     * Finds the image URN for a given page URN from an array of DSERecords.
     * @param {string} pageUrn - The CITE2 URN identifying the page.
     * @param {HMTLib.DSERecord[]} dseRecordsArray - An array of DSERecord objects.
     * @returns {string | null} The image URN (without ROI), or null.
     */
    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input.");
            return null;
        }
        const matchingPageRecords = HMTLib.recordsforpage(pageUrn, dseRecordsArray);
        if (matchingPageRecords.length > 0) {
            const firstRecord = matchingPageRecords[0];
            if (firstRecord && firstRecord.imageroi && typeof firstRecord.imageroi === 'string') {
                const imageroi = firstRecord.imageroi;
                const roiSeparatorIndex = imageroi.lastIndexOf('@');
                return roiSeparatorIndex !== -1 ? imageroi.substring(0, roiSeparatorIndex) : imageroi;
            }
        }
        return null;
    }


    // --- NEW SCHOLIA FUNCTIONS ---

    /**
     * Extracts Scholion objects from 'citerelationset' blocks,
     * specifically from 'urn:cite2:hmt:commentary.v1:all'.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {HMTLib.Scholion[]} An array of Scholion objects.
     */
    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";

        if (!(parserInstance instanceof CEXParser)) {
            console.error("Invalid parserInstance provided to hmtscholia.");
            return [];
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) {
                    processedLines.push(trimmedLine);
                }
            }

            // Need at least URN line, label line, and header line
            if (processedLines.length < 3) {
                continue;
            }

            let currentBlockUrn = null;
            if (processedLines[0].startsWith("urn|")) {
                currentBlockUrn = processedLines[0].substring("urn|".length);
            } else {
                continue; // Malformed block, missing URN line
            }

            // Optional: check label line
            // if (!processedLines[1].startsWith("label|")) { ... }

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2]; // Header is the third processed line
                if (headerLine !== expectedHeader) {
                    console.warn(`Skipping commentary block ${currentBlockUrn}: Header mismatch. Expected "${expectedHeader}", found "${headerLine}".`);
                    continue;
                }

                // Data rows start from index 3 of processedLines (i.e., the 4th processed line onwards)
                for (let i = 3; i < processedLines.length; i++) {
                    const dataLine = processedLines[i];
                    const columns = dataLine.split('|');

                    if (columns.length === 2) { // scholion_urn, iliad_urn
                        const scholionRecord = new HMTLib.Scholion(columns[0], columns[1]);
                        scholiaRecords.push(scholionRecord);
                    } else {
                        console.warn(`Skipping data row in commentary block ${currentBlockUrn}: Incorrect number of columns. Expected 2, found ${columns.length}. Row: "${dataLine}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    /**
     * Finds the Iliad passage URN that a specific scholion URN refers to.
     * @param {string} scholionUrnToFind - The CTS URN of the scholion.
     * @param {HMTLib.Scholion[]} scholiaArray - An array of Scholion objects.
     * @returns {string | null} The CTS URN of the Iliad passage, or null if not found.
     */
    function passageforscholion(scholionUrnToFind, scholiaArray) {
        if (!scholionUrnToFind || typeof scholionUrnToFind !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("passageforscholion: Invalid input.");
            return null;
        }
        const foundScholion = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrnToFind);
        return foundScholion ? foundScholion.iliad : null;
    }

    /**
     * Finds all scholia URNs that refer to a specific Iliad passage URN.
     * @param {string} iliadPassageUrnToFind - The CTS URN of the Iliad passage.
     * @param {HMTLib.Scholion[]} scholiaArray - An array of Scholion objects.
     * @returns {string[]} An array of scholion CTS URNs (possibly empty).
     */
    function scholiaforpassage(iliadPassageUrnToFind, scholiaArray) {
        if (!iliadPassageUrnToFind || typeof iliadPassageUrnToFind !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("scholiaforpassage: Invalid input.");
            return [];
        }
        return scholiaArray
            .filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadPassageUrnToFind)
            .map(s => s.scholion);
    }


    // Expose functions and classes via the HMTLib namespace
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion; // Expose new class

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;

    window.HMTLib.hmtscholia = hmtscholia; // Expose new functions
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;


})(window);
```

**2. `test_scholia.html` (New HTML test file)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Scholia Functions</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .results-section { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        pre { background-color: #eef; padding: 10px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; max-height: 300px; overflow-y: auto; }
        h2, h3 { margin-top: 1em; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js (HMTLib uses it for other functions) -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js (ensure this path is correct) -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: Scholion Functions</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data and scholia records... Please wait.</p>
    </div>

    <div id="testResults" style="display:none;">
        <div class="results-section">
            <h3>Test <code>hmtscholia</code></h3>
            <p>Total number of Scholion objects: <strong id="totalScholiaCount">N/A</strong></p>
        </div>

        <div class="results-section">
            <h3>Test <code>passageforscholion</code></h3>
            <p>Searching for Iliad passage for scholion: <code>urn:cts:greekLit:tlg5026.msAint.hmt:1.27</code></p>
            <p>Iliad passage URN found:</p>
            <pre id="passageForScholionOutput">N/A</pre>
        </div>

        <div class="results-section">
            <h3>Test <code>scholiaforpassage</code></h3>
            <p>Searching for scholia for Iliad passage: <code>urn:cts:greekLit:tlg0012.tlg001.msA:1.1</code></p>
            <p>Scholia URNs found (<span id="scholiaForPassageCount">0</span>):</p>
            <pre id="scholiaForPassageOutput">N/A</pre>
        </div>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runScholiaTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const testResultsDiv = document.getElementById('testResults');
            const errorLogDiv = document.getElementById('errorLog');

            const totalScholiaCountEl = document.getElementById('totalScholiaCount');
            const passageForScholionOutputEl = document.getElementById('passageForScholionOutput');
            const scholiaForPassageCountEl = document.getElementById('scholiaForPassageCount');
            const scholiaForPassageOutputEl = document.getElementById('scholiaForPassageOutput');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console for details.</p>`;
                console.error(message, errorObj || '');
            }

            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return 'null';
                return unsafe
                    .toString()
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.Scholion || !HMTLib.hmtscholia ||
                !HMTLib.passageforscholion || !HMTLib.scholiaforpassage) {
                showError("<strong>Error:</strong> A required library (CEXParser, URNTools, HMTLib) or HMTLib scholia function is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Processing scholia records...</p>`;
                
                const allScholiaRecords = HMTLib.hmtscholia(parserInstance);
                console.log(`Total Scholion Records fetched by hmtscholia: ${allScholiaRecords.length}`);

                if (allScholiaRecords.length === 0) {
                     console.warn("Warning: No Scholion records were found by `hmtscholia`. Check target URN and CEX file structure if this is unexpected.");
                }
                totalScholiaCountEl.textContent = allScholiaRecords.length;
                loadingStatusDiv.innerHTML = `<p class="status success">Scholia records processed (${allScholiaRecords.length} found). Running query tests...</p>`;

                // Test passageforscholion
                const scholionUrnToTest = "urn:cts:greekLit:tlg5026.msAint.hmt:1.27";
                const foundIliadPassage = HMTLib.passageforscholion(scholionUrnToTest, allScholiaRecords);
                passageForScholionOutputEl.textContent = escapeHtml(foundIliadPassage) || "Iliad passage not found (result is null).";
                console.log(`Test passageforscholion with scholion URN ${scholionUrnToTest}: Result is '${foundIliadPassage}'`);

                // Test scholiaforpassage
                const iliadPassageToTest = "urn:cts:greekLit:tlg0012.tlg001.msA:1.1";
                const foundScholiaUrns = HMTLib.scholiaforpassage(iliadPassageToTest, allScholiaRecords);
                scholiaForPassageCountEl.textContent = foundScholiaUrns.length;
                if (foundScholiaUrns.length > 0) {
                    scholiaForPassageOutputEl.textContent = foundScholiaUrns.map(escapeHtml).join('\n');
                } else {
                    scholiaForPassageOutputEl.textContent = "No scholia URNs found for this Iliad passage.";
                }
                console.log(`Test scholiaforpassage with Iliad passage URN ${iliadPassageToTest}: Found ${foundScholiaUrns.length} scholia.`, foundScholiaUrns);

                testResultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">All scholia query tests complete.</p>`;

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runScholiaTest();
    </script>
</body>
</html>
```

**Key changes and considerations:**

*   **`hmt-lib.js`**:
    *   Added the `Scholion` class.
    *   Added `hmtscholia` to parse the `urn:cite2:hmt:commentary.v1:all` relation set, expecting the header `scholion|iliad`.
    *   Added `passageforscholion` to find the Iliad URN for a given scholion URN.
    *   Added `scholiaforpassage` to find all scholia URNs for a given Iliad passage URN.
    *   All new classes and functions are exposed under `window.HMTLib`.
*   **`test_scholia.html`**:
    *   Loads the HMT data using `hmtcurrent`.
    *   Calls `hmtscholia` to get the array of `Scholion` objects and displays the count.
    *   Tests `passageforscholion` with `urn:cts:greekLit:tlg5026.msAint.hmt:1.27` and displays the resulting Iliad passage URN.
    *   Tests `scholiaforpassage` with `urn:cts:greekLit:tlg0012.tlg001.msA:1.1` and displays the list of scholia URNs.

This should give you a robust set of tools for working with scholia data from the HMT CEX files!

### USER
  
Amazing. Now I want to create a new class `CodexPage` with properties `sequence` (a numeric value), `image`, `urn`, `rv` and `label`. I want a function called `codex` that takes two parameters, an instance of a CEXParser, and a CITE2 URN identifying a codex, and then returns an Array of `CodexPage` objects. Here's how. First, get the contents of all CITE relation sets by using the current instance of `CEXParser` with `getBlockContents("citedata")`. Each block is a delimited text table with columns separated by the pipe character '!'. There will be a header line: note the column names. One should be `urn`. For each row in the table, look at the value of the `urn` column and final object identifier it to compare it to the given CITE2 URN. For example, if the `urn` column had the value `urn:cite2:hmt:msA.v1:12r`, you would drop `12r`, and compare `urn:cite2:hmt:msA.v1:` to the given CITE2 URN for the codex. If the URNs match, create a `CodexPage` object, using values from the columns labelled `sequence`, `image`, `urn`, `rv` and `label` for the corresponding properties of the `CodexPage` instance. Note that you must refer to the table header to find their position in the table: the order of columns is not predetermined.
  
**Test**: Please implement this and test it by writing an HTML page that loads the current HMT release, and uses the `codex` function to find an Array of `CodexPage` objects for the URN `urn:cite2:hmt:msA.v1:`.

### ASSISTANT
This is another excellent set of requirements for expanding your HMT library! We'll implement the `CodexPage` class and the `codex` function, then test them.

Here's the plan:

1.  **`CodexPage` Class**: Define this with properties `sequence` (numeric), `image` (string), `urn` (string, the page's full URN), `rv` (string), and `label` (string).
2.  **`codex` Function**:
    *   It will take a `CEXParser` instance and a `codexUrnPrefix` (e.g., `urn:cite2:hmt:msA.v1:`).
    *   It will process `citedata` blocks.
    *   For each `citedata` block, it will read the header to map column names (`urn`, `sequence`, `image`, `rv`, `label`) to their respective indices. The column order is not fixed.
    *   For each data row, it will extract the URN from the `urn` column.
    *   It will then derive the prefix of this row's URN (e.g., `urn:cite2:hmt:msA.v1:12r` -> `urn:cite2:hmt:msA.v1:`) using `URNTools`.
    *   If this derived prefix matches the input `codexUrnPrefix`, a `CodexPage` object will be created using values from the corresponding columns and added to the result array.
3.  **Test HTML Page**: This page will load the HMT data, call `codex` with `urn:cite2:hmt:msA.v1:`, and display the total count and details of the first 10 `CodexPage` objects.

**1. `hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    /**
     * Represents a page in a codex.
     */
    class CodexPage {
        /**
         * Creates an instance of CodexPage.
         * @param {number} sequence - The sequence number of the page.
         * @param {string} image - The CITE2 URN of the image for this page.
         * @param {string} urn - The CITE2 URN of this page object itself.
         * @param {string} rv - The recto/verso indicator (e.g., 'r', 'v').
         * @param {string} label - The human-readable label for the page.
         */
        constructor(sequence, image, urn, rv, label) {
            this.sequence = sequence; // numeric
            this.image = image;     // CITE2 URN
            this.urn = urn;         // CITE2 URN of the page
            this.rv = rv;           // string (e.g., 'r', 'v')
            this.label = label;     // string
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser not defined.");
            return Promise.reject(new Error("CEXParser not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    // ... (hmtnormalized, hmtdiplomatic, hmtdse, recordsforpage, recordforpassage, imageforpage, hmtscholia, passageforscholion, scholiaforpassage functions remain unchanged) ...
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtdse."); return []; }
        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }
            if (processedLines.length < 3) continue;
            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;
            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { console.warn(`DSE Header mismatch in ${currentBlockUrn}`); continue; }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    else console.warn(`DSE wrong column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return [];
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || !Array.isArray(dseRecordsArray)) return null;
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return null;
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray);
        if (recs.length > 0 && recs[0].imageroi) {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtscholia."); return []; }
        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }
            if (processed.length < 3) continue;
            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn || blockUrn !== targetUrn) continue;
            if (processed[2] !== expectedHeader) { console.warn(`Scholia Header mismatch in ${blockUrn}`); continue; }
            for (let i = 3; i < processed.length; i++) {
                const cols = processed[i].split('|');
                if (cols.length === 2) scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                else console.warn(`Scholia wrong column count in ${blockUrn}, row: "${processed[i]}"`);
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || !Array.isArray(scholiaArray)) return null;
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || !Array.isArray(scholiaArray)) return [];
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }

    // --- NEW CODEX FUNCTIONS ---

    /**
     * Extracts CodexPage objects from 'citedata' blocks that match a given codex URN prefix.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @param {string} codexUrnPrefix - The CITE2 URN prefix identifying the codex (e.g., "urn:cite2:hmt:msA.v1:").
     * @returns {HMTLib.CodexPage[]} An array of CodexPage objects.
     */
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];

        if (!(parserInstance instanceof CEXParser)) {
            console.error("codex: Invalid parserInstance provided.");
            return [];
        }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) {
            console.error("codex: codexUrnPrefix must be a string ending with a colon (e.g., 'urn:cite2:namespace:collection:').");
            return [];
        }
        if (typeof URNTools === 'undefined') {
            console.error("codex: URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }


        const citeDataBlocks = parserInstance.getBlockContents("citedata");

        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null;
            let dataLinesStartIdx = -1;
            const columnIndexMap = {};

            // Find header and data start
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    continue;
                }
                if (!headerLine) {
                    headerLine = trimmedLine;
                    const headerParts = headerLine.split('|');
                    headerParts.forEach((name, idx) => {
                        columnIndexMap[name.trim()] = idx;
                    });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }

            if (!headerLine) {
                // console.warn("codex: Skipping citedata block - no header found.");
                continue;
            }

            // Check if all required columns are in the header
            let missingColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') {
                    console.warn(`codex: Skipping citedata block - header missing required column '${colName}'. Header: "${headerLine}"`);
                    missingColumn = true;
                    break;
                }
            }
            if (missingColumn) {
                continue;
            }

            // Process data lines
            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    continue;
                }

                const columnValues = trimmedLine.split('|');
                
                // Ensure the row has enough columns as per header
                // This simple check assumes no pipes within quoted fields; CEX is usually simpler.
                if (columnValues.length < Object.keys(columnIndexMap).length) {
                     // console.warn(`codex: Skipping data row due to insufficient columns compared to header. Row: "${trimmedLine}"`);
                     continue;
                }

                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();

                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) {
                    // console.warn(`codex: Skipping row with invalid CITE2 URN: ${currentRowFullUrn}`);
                    continue;
                }
                
                const rowNamespace = URNTools.cite2namespace(currentRowFullUrn);
                const rowCollection = URNTools.collectioncomponent(currentRowFullUrn);

                if (!rowNamespace || !rowCollection) {
                    // console.warn(`codex: Could not extract namespace or collection from URN: ${currentRowFullUrn}`);
                    continue;
                }

                const currentRowPrefix = `urn:cite2:${rowNamespace}:${rowCollection}:`;

                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        const sequence = parseFloat(sequenceStr);
                        if (isNaN(sequence)) {
                           // console.warn(`codex: Invalid sequence number "${sequenceStr}" for URN ${currentRowFullUrn}. Skipping.`);
                           continue;
                        }

                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();

                        const page = new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label);
                        codexPagesResult.push(page);
                    } catch (e) {
                        console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`);
                    }
                }
            }
        }
        return codexPagesResult;
    }


    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage; // New class

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex; // New function

})(window);
```

**2. `test_codex.html` (New HTML test file)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Codex Function</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .results-section { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        pre { background-color: #eef; padding: 10px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow-y: auto; }
        h2, h3 { margin-top: 1em; }
        .page-item { border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-bottom: 5px; }
        .page-item:last-child { border-bottom: none; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>codex</code> Function</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data and processing codex pages... Please wait.</p>
    </div>

    <div id="testResults" style="display:none;">
        <div class="results-section">
            <h3>Test <code>codex</code> for URN Prefix: <code id="testedCodexUrn"></code></h3>
            <p>Total number of CodexPage objects found: <strong id="totalCodexPages">N/A</strong></p>
            <p>First 10 CodexPage Objects (if available):</p>
            <pre id="codexPagesOutput">N/A</pre>
        </div>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runCodexTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const testResultsDiv = document.getElementById('testResults');
            const errorLogDiv = document.getElementById('errorLog');

            const testedCodexUrnEl = document.getElementById('testedCodexUrn');
            const totalCodexPagesEl = document.getElementById('totalCodexPages');
            const codexPagesOutputEl = document.getElementById('codexPagesOutput');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console.</p>`;
                console.error(message, errorObj || '');
            }

            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return 'null';
                return unsafe.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }
            
            function formatCodexPage(page) {
                return `  Sequence: ${escapeHtml(page.sequence)}\n` +
                       `  Label:    ${escapeHtml(page.label)}\n` +
                       `  URN:      ${escapeHtml(page.urn)}\n` +
                       `  Image:    ${escapeHtml(page.image)}\n` +
                       `  R/V:      ${escapeHtml(page.rv)}`;
            }

            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.CodexPage || !HMTLib.codex) {
                showError("<strong>Error:</strong> A required library (CEXParser, URNTools, HMTLib) or HMTLib codex function/class is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            const codexUrnToTest = "urn:cite2:hmt:msA.v1:";
            testedCodexUrnEl.textContent = codexUrnToTest;

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Processing codex pages for ${codexUrnToTest}...</p>`;
                
                const codexPages = HMTLib.codex(parserInstance, codexUrnToTest);
                console.log(`CodexPage objects found by HMTLib.codex for ${codexUrnToTest}: ${codexPages.length}`);
                console.log("First few codex pages:", codexPages.slice(0,5));

                totalCodexPagesEl.textContent = codexPages.length;

                if (codexPages.length > 0) {
                    let output = "";
                    const limit = Math.min(10, codexPages.length);
                    for (let i = 0; i < limit; i++) {
                        output += `Page Record ${i + 1} (of ${codexPages.length}):\n${formatCodexPage(codexPages[i])}\n\n`;
                    }
                    if (codexPages.length > 10) {
                        output += `... and ${codexPages.length - 10} more records not shown.`;
                    }
                    codexPagesOutputEl.textContent = output.trim();
                } else {
                    codexPagesOutputEl.textContent = "No CodexPage objects found matching the criteria.";
                }

                testResultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">Codex processing complete.</p>`;

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runCodexTest();
    </script>
</body>
</html>
```

**Key changes and considerations:**

*   **`hmt-lib.js`**:
    *   Added the `CodexPage` class with `sequence`, `image`, `urn`, `rv`, and `label` properties.
    *   Implemented the `codex` function:
        *   It iterates through `citedata` blocks obtained via `parserInstance.getBlockContents("citedata")`.
        *   For each block, it identifies the header line and maps column names to indices. It specifically looks for `urn`, `sequence`, `image`, `rv`, and `label`.
        *   It processes data rows, extracts the `urn` value from the specified column.
        *   Using `URNTools.cite2namespace` and `URNTools.collectioncomponent`, it constructs the prefix of the row's URN (e.g., `urn:cite2:hmt:msA.v1:`).
        *   If this prefix matches the `codexUrnPrefix` passed to the function, it creates a `CodexPage` object. The `sequence` is converted to a number using `parseFloat`.
        *   Error handling and warnings are included for missing headers, missing columns, invalid URNs, and non-numeric sequences.
    *   The `CodexPage` class and `codex` function are exposed under `window.HMTLib`.
*   **`test_codex.html`**:
    *   Loads CEX, URN, and your HMT library.
    *   Calls `HMTLib.hmtcurrent()` to get the parser.
    *   Calls `HMTLib.codex(parser, "urn:cite2:hmt:msA.v1:")`.
    *   Displays the total number of `CodexPage` objects found.
    *   Displays the properties of the first 10 `CodexPage` objects.

This implementation should correctly parse the `citedata` blocks and create the `CodexPage` objects as specified. The use of `URNTools` ensures robust URN prefix matching.

### USER
  
Great! Now let's add a two metadata functions. 1) `collectionlabel` should take 2 parameters, a CITE2 URN for a collection, and an instance of a CEXParser, and should return a string label for the collection. Here's how: use the instance of `CEXParser` with `getDelimitedData("citecollections")`. The result is a delimited-text table with a pipe-delimited header `URN|Description|Labelling property|Ordering property|License`. Find the row with the `URN` column matching the given CITE2 URN, and return the value of tis `Description` property.
  
2) `textlabel` should take 2 parameters, a CTS URN for a text, and an instance of a CEXParser, and should return a string label for the collection. Here's how: use the instance of `CEXParser` with `getDelimitedData("ctscatalog")`. The result is a delimited-text table with a pipe-delimited header `urn|citationScheme|groupName|workTitle|versionLabel|exemplarLabel|online|language`. Find the row with the `URN` column matching the given CITE2 URN. Create a label by joining the columns
`groupName` and `workTitle` with a string ", " followed by `versionLabel` in parentheses.  If the entry has a value for exemplar, append a space and then the value of exemplar. For example, if you matched a row with the values `urn:cts:greekLit:tlg0012.tlg001.msA.normalized:|book,line|Homeric poetry|Iliad|Venetus A (Marciana 454 = 822)|normalized|true|grc`, the returned label should be "Homeric poetry, Iliad (Venetus A (Marciana 454 = 822)) normalized"
  
  
**Test**: Please implement this and test it by writing an HTML page that loads the current HMT release. Then use the `collectionlabel` to find and display a label for the collection with CITE2 URN `urn:cite2:hmt:msA.v1:`. Then use the `textlabel` function to find and display a label for the text `urn:cts:greekLit:tlg0012.tlg001.msA:`.

### ASSISTANT
Okay, these metadata functions will be very useful for retrieving human-readable labels for collections and texts. We'll add `collectionlabel` and `textlabel` to your `hmt-lib.js` and create a test HTML page.

**1. `hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = sequence;
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser not defined.");
            return Promise.reject(new Error("CEXParser not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    // ... (hmtnormalized, hmtdiplomatic, hmtdse, DSE queries, hmtscholia, scholia queries, codex functions remain unchanged) ...
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtdse."); return []; }
        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }
            if (processedLines.length < 3) continue;
            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;
            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { console.warn(`DSE Header mismatch in ${currentBlockUrn}`); continue; }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    else console.warn(`DSE wrong column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return [];
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || !Array.isArray(dseRecordsArray)) return null;
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return null;
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray);
        if (recs.length > 0 && recs[0].imageroi) {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtscholia."); return []; }
        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }
            if (processed.length < 3) continue;
            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn || blockUrn !== targetUrn) continue;
            if (processed[2] !== expectedHeader) { console.warn(`Scholia Header mismatch in ${blockUrn}`); continue; }
            for (let i = 3; i < processed.length; i++) {
                const cols = processed[i].split('|');
                if (cols.length === 2) scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                else console.warn(`Scholia wrong column count in ${blockUrn}, row: "${processed[i]}"`);
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || !Array.isArray(scholiaArray)) return null;
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || !Array.isArray(scholiaArray)) return [];
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];
        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must end with ':'."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools not defined."); return []; }
        const citeDataBlocks = parserInstance.getBlockContents("citedata");
        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;
            let missingColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { console.warn(`codex: Missing column '${colName}' in header "${headerLine}"`); missingColumn = true; break; }
            }
            if (missingColumn) continue;
            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                const columnValues = trimmedLine.split('|');
                if (columnValues.length < Object.keys(columnIndexMap).length) continue;
                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) continue;
                const rowNamespace = URNTools.cite2namespace(currentRowFullUrn);
                const rowCollection = URNTools.collectioncomponent(currentRowFullUrn);
                if (!rowNamespace || !rowCollection) continue;
                const currentRowPrefix = `urn:cite2:${rowNamespace}:${rowCollection}:`;
                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequence = parseFloat(columnValues[columnIndexMap['sequence']].trim());
                        if (isNaN(sequence)) continue;
                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label));
                    } catch (e) { console.error(`codex: Error creating CodexPage: ${e.message}`); }
                }
            }
        }
        return codexPagesResult;
    }

    // --- NEW METADATA FUNCTIONS ---

    /**
     * Retrieves the label for a CITE2 collection URN from 'citecollections' data.
     * @param {string} collectionCite2Urn - The CITE2 URN of the collection.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string | null} The description of the collection, or null if not found or error.
     */
    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') {
            console.error("collectionlabel: collectionCite2Urn parameter is invalid.");
            return null;
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("collectionlabel: parserInstance parameter is invalid.");
            return null;
        }

        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) {
            // console.warn("collectionlabel: No data found for 'citecollections'.");
            return null;
        }

        const lines = dataString.split('\n');
        if (lines.length < 1) { // Should have at least header
             // console.warn("collectionlabel: 'citecollections' data is empty or malformed (no header).");
            return null;
        }

        // The first line is the header: URN|Description|Labelling property|Ordering property|License
        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");

        if (urnIndex === -1 || descriptionIndex === -1) {
            console.error("collectionlabel: 'URN' or 'Description' column not found in 'citecollections' header.");
            return null;
        }

        for (let i = 1; i < lines.length; i++) { // Start from 1 to skip header
            const line = lines[i].trim();
            if (line === "") continue; // Skip any potentially empty lines if not already filtered

            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                const urnValue = rowParts[urnIndex].trim();
                if (urnValue === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            } else {
                // console.warn(`collectionlabel: Row has insufficient columns: "${line}"`);
            }
        }
        // console.warn(`collectionlabel: URN "${collectionCite2Urn}" not found in 'citecollections'.`);
        return null; // Not found
    }

    /**
     * Retrieves and formats a label for a CTS URN from 'ctscatalog' data.
     * @param {string} textCtsUrn - The CTS URN of the text.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string | null} The formatted label, or null if not found or error.
     */
    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') {
            console.error("textlabel: textCtsUrn parameter is invalid.");
            return null;
        }
        if (!(parserInstance instanceof CEXParser)) {
            console.error("textlabel: parserInstance parameter is invalid.");
            return null;
        }

        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) {
            // console.warn("textlabel: No data found for 'ctscatalog'.");
            return null;
        }

        const lines = dataString.split('\n');
        if (lines.length < 1) { // Should have at least header
            // console.warn("textlabel: 'ctscatalog' data is empty or malformed (no header).");
            return null;
        }

        // Header: urn|citationScheme|groupName|workTitle|versionLabel|exemplarLabel|online|language
        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"),
            groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"),
            versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };

        // Check if all required columns for label construction are present
        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) {
            console.error("textlabel: One or more required columns (urn, groupName, workTitle, versionLabel) not found in 'ctscatalog' header.");
            return null;
        }
        // exemplarLabel is optional for presence in header, but if present, its index is needed.
        // If not present, colIndices.exemplarLabel will be -1, handled below.

        for (let i = 1; i < lines.length; i++) { // Start from 1 to skip header
            const line = lines[i].trim();
            if (line === "") continue;

            const rowParts = line.split('|');
            
            // Ensure row is long enough for the URN column
            if (rowParts.length <= colIndices.urn) {
                // console.warn(`textlabel: Row has insufficient columns for URN: "${line}"`);
                continue;
            }

            const currentUrn = rowParts[colIndices.urn].trim();
            if (currentUrn === textCtsUrn) {
                // Ensure row is long enough for all other required parts for label
                if (rowParts.length <= colIndices.groupName || 
                    rowParts.length <= colIndices.workTitle || 
                    rowParts.length <= colIndices.versionLabel) {
                    // console.warn(`textlabel: Matched URN "${currentUrn}" but row has insufficient columns for label parts: "${line}"`);
                    return null; // or skip this row if other URNs might match
                }

                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }

                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        // console.warn(`textlabel: URN "${textCtsUrn}" not found in 'ctscatalog'.`);
        return null; // Not found
    }


    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex;
    
    window.HMTLib.collectionlabel = collectionlabel; // New
    window.HMTLib.textlabel = textlabel;         // New

})(window);
```

**2. `test_metadata_labels.html` (New HTML test file)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Metadata Label Functions</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .results-section { border: 1px solid #ccc; padding: 15px; background-color: #f9f9f9; margin-top: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        pre { background-color: #eef; padding: 10px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; }
        h2, h3 { margin-top: 1em; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js (though not directly used by these new functions, good for HMTLib consistency) -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: Metadata Label Functions</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data... Please wait.</p>
    </div>

    <div id="testResults" style="display:none;">
        <div class="results-section">
            <h3>Test <code>collectionlabel</code></h3>
            <p>For Collection URN: <code>urn:cite2:hmt:msA.v1:</code></p>
            <p>Label found:</p>
            <pre id="collectionLabelOutput">N/A</pre>
        </div>

        <div class="results-section">
            <h3>Test <code>textlabel</code></h3>
            <p>For Text URN: <code>urn:cts:greekLit:tlg0012.tlg001.msA:</code></p>
            <p>Label found:</p>
            <pre id="textLabelOutput">N/A</pre>
        </div>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runMetadataLabelTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const testResultsDiv = document.getElementById('testResults');
            const errorLogDiv = document.getElementById('errorLog');

            const collectionLabelOutputEl = document.getElementById('collectionLabelOutput');
            const textLabelOutputEl = document.getElementById('textLabelOutput');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console.</p>`;
                console.error(message, errorObj || '');
            }
            
            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return 'Label not found or error.';
                return unsafe.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }


            if (typeof CEXParser === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.collectionlabel || !HMTLib.textlabel) {
                showError("<strong>Error:</strong> A required library (CEXParser, HMTLib) or HMTLib metadata function is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Fetching labels...</p>`;
                
                // Test collectionlabel
                const collectionUrnToTest = "urn:cite2:hmt:msA.v1:";
                const foundCollectionLabel = HMTLib.collectionlabel(collectionUrnToTest, parserInstance);
                collectionLabelOutputEl.textContent = escapeHtml(foundCollectionLabel);
                console.log(`Test collectionlabel for ${collectionUrnToTest}:`, foundCollectionLabel);

                // Test textlabel
                const textUrnToTest = "urn:cts:greekLit:tlg0012.tlg001.msA:";
                const foundTextLabel = HMTLib.textlabel(textUrnToTest, parserInstance);
                textLabelOutputEl.textContent = escapeHtml(foundTextLabel);
                console.log(`Test textlabel for ${textUrnToTest}:`, foundTextLabel);


                testResultsDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">Metadata label tests complete.</p>`;

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runMetadataLabelTest();
    </script>
</body>
</html>
```

**Key changes and considerations:**

*   **`hmt-lib.js`**:
    *   Added `collectionlabel(collectionCite2Urn, parserInstance)`:
        *   Uses `parserInstance.getDelimitedData("citecollections")`.
        *   Parses the resulting string, expecting the first line to be the header `URN|Description|Labelling property|Ordering property|License`.
        *   Finds the row where the `URN` column matches `collectionCite2Urn` and returns the `Description`.
    *   Added `textlabel(textCtsUrn, parserInstance)`:
        *   Uses `parserInstance.getDelimitedData("ctscatalog")`.
        *   Parses the string, expecting header `urn|citationScheme|groupName|workTitle|versionLabel|exemplarLabel|online|language`.
        *   Finds the row where the `urn` column (note: lowercase 'urn' as per common CEX practice for `ctscatalog`) matches `textCtsUrn`.
        *   Constructs the label as specified: `groupName` + ", " + `workTitle` + " (" + `versionLabel` + ")" and appends " " + `exemplarLabel` if present.
    *   Both functions include checks for valid input and presence of required columns in headers, returning `null` on failure or if the URN is not found.
*   **`test_metadata_labels.html`**:
    *   Loads the HMT data.
    *   Calls `HMTLib.collectionlabel` with `urn:cite2:hmt:msA.v1:` and displays the result.
    *   Calls `HMTLib.textlabel` with `urn:cts:greekLit:tlg0012.tlg001.msA:` and displays the result.

This implementation should accurately retrieve and format the labels as requested. The use of `getDelimitedData` from `cex-lib.js` is central here, and the functions handle the parsing of its string output.

### USER
  
Super! I'd like to add a function `codexmenu` that builds an HTML options menu to let users choose a codex. It should take three parameters: an instance of a CEX Parser, a name for the select element, an ID for the select element. The menu should create the options as follows. Use the CEXParser with the function `getCollectionsForModel("urn:cite2:hmt:datamodels.v1:codexmodel")` to get a list of CITE2 URNs for codices. Create an `option` element for each URN in the list. The URN should be value of the option element. The contents of the element should be the output of using the `collectionlabel` function with that URN.
  
**Test**: Please implement this and test it by writing an HTML page that loads the current HMT release, displays a menu created by the `codexmenu` function, then displays the user's  current selection .

### ASSISTANT
Okay, this `codexmenu` function will be a great UI addition to your library! It will dynamically generate an HTML dropdown menu for selecting codices.

Here's the implementation:

**1. `hmt-lib.js` (Updated)**

We'll add the `codexmenu` function. It will use the `getDelimitedData` method to parse the `datamodels` block (as `getCollectionsForModel` isn't a direct method of `CEXParser` per the docs, but we can achieve the same result by filtering `datamodels`) and then use your existing `collectionlabel` function.

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord { /* ... */ }
    class Scholion { /* ... */ }
    class CodexPage { /* ... */ }
    // (Ensure all previous classes DSERecord, Scholion, CodexPage are defined here)
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = sequence; // numeric
            this.image = image;     // CITE2 URN
            this.urn = urn;         // CITE2 URN of the page
            this.rv = rv;           // string (e.g., 'r', 'v')
            this.label = label;     // string
        }
    }


    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() { /* ... */ }
    // (Ensure all previous functions hmtcurrent, hmtnormalized, hmtdiplomatic, hmtdse, 
    //  recordsforpage, recordforpassage, imageforpage, hmtscholia, passageforscholion, 
    //  scholiaforpassage, codex, collectionlabel, textlabel are defined here)
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("CEXParser not defined.");
            return Promise.reject(new Error("CEXParser not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }
    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtdse."); return []; }
        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }
            if (processedLines.length < 3) continue;
            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;
            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { console.warn(`DSE Header mismatch in ${currentBlockUrn}`); continue; }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    else console.warn(`DSE wrong column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return [];
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || !Array.isArray(dseRecordsArray)) return null;
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || !Array.isArray(dseRecordsArray)) return null;
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray);
        if (recs.length > 0 && recs[0].imageroi) {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";
        if (!(parserInstance instanceof CEXParser)) { console.error("Invalid parserInstance to hmtscholia."); return []; }
        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }
            if (processed.length < 3) continue;
            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn || blockUrn !== targetUrn) continue;
            if (processed[2] !== expectedHeader) { console.warn(`Scholia Header mismatch in ${blockUrn}`); continue; }
            for (let i = 3; i < processed.length; i++) {
                const cols = processed[i].split('|');
                if (cols.length === 2) scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                else console.warn(`Scholia wrong column count in ${blockUrn}, row: "${processed[i]}"`);
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || !Array.isArray(scholiaArray)) return null;
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || !Array.isArray(scholiaArray)) return [];
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];
        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must end with ':'."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools not defined."); return []; }
        const citeDataBlocks = parserInstance.getBlockContents("citedata");
        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;
            let missingColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { console.warn(`codex: Missing column '${colName}' in header "${headerLine}"`); missingColumn = true; break; }
            }
            if (missingColumn) continue;
            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                const columnValues = trimmedLine.split('|');
                if (columnValues.length < Object.keys(columnIndexMap).length) continue;
                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) continue;
                const rowNamespace = URNTools.cite2namespace(currentRowFullUrn);
                const rowCollection = URNTools.collectioncomponent(currentRowFullUrn);
                if (!rowNamespace || !rowCollection) continue;
                const currentRowPrefix = `urn:cite2:${rowNamespace}:${rowCollection}:`;
                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequence = parseFloat(columnValues[columnIndexMap['sequence']].trim());
                        if (isNaN(sequence)) continue;
                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label));
                    } catch (e) { console.error(`codex: Error creating CodexPage: ${e.message}`); }
                }
            }
        }
        return codexPagesResult;
    }
    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || !(parserInstance instanceof CEXParser)) return null;
        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;
        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");
        if (urnIndex === -1 || descriptionIndex === -1) return null;
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex) && rowParts[urnIndex].trim() === collectionCite2Urn) {
                return rowParts[descriptionIndex].trim();
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || !(parserInstance instanceof CEXParser)) return null;
        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;
        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };
        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) return null;
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;
            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                let label = `${rowParts[colIndices.groupName].trim()}, ${rowParts[colIndices.workTitle].trim()} (${rowParts[colIndices.versionLabel].trim()})`;
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel && rowParts[colIndices.exemplarLabel].trim()) {
                    label += ` ${rowParts[colIndices.exemplarLabel].trim()}`;
                }
                return label;
            }
        }
        return null;
    }

    // --- NEW MENU FUNCTION ---
    /**
     * Builds an HTML select menu for choosing a codex.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @param {string} selectName - The 'name' attribute for the select element.
     * @param {string} selectId - The 'id' attribute for the select element.
     * @returns {string} An HTML string representing the <select> element.
     */
    function codexmenu(parserInstance, selectName, selectId) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexmenu: Invalid parserInstance.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: Invalid Parser</option></select>`;
        }
        if (typeof URNTools === 'undefined') {
             console.error("codexmenu: URNTools is not defined. Ensure urn-lib.js is loaded.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: URNTools missing</option></select>`;
        }
        if (typeof HMTLib.collectionlabel !== 'function') {
             console.error("codexmenu: HMTLib.collectionlabel is not defined.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: collectionlabel missing</option></select>`;
        }


        let optionsHtml = '';
        const targetModel = "urn:cite2:hmt:datamodels.v1:codexmodel";
        const codexCollectionUrns = [];

        // 1. Get collections for the codex model from 'datamodels' block
        const datamodelsString = parserInstance.getDelimitedData("datamodels");
        if (datamodelsString) {
            const lines = datamodelsString.split('\n');
            if (lines.length > 0) {
                const header = lines[0].split('|').map(h => h.trim());
                // Expected header for datamodels: urn|label|model|collection
                const modelIndex = header.indexOf("model");
                const collectionIndex = header.indexOf("collection");

                if (modelIndex !== -1 && collectionIndex !== -1) {
                    for (let i = 1; i < lines.length; i++) {
                        const row = lines[i].trim();
                        if (row) {
                            const parts = row.split('|');
                            if (parts.length > Math.max(modelIndex, collectionIndex)) {
                                const modelValue = parts[modelIndex].trim();
                                if (modelValue === targetModel) {
                                    const collectionUrn = parts[collectionIndex].trim();
                                    // Ensure it's a valid CITE2 URN and not already added
                                    if (URNTools.isValidCite2Urn(collectionUrn) && !codexCollectionUrns.includes(collectionUrn)) {
                                        codexCollectionUrns.push(collectionUrn);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    console.error("codexmenu: 'model' or 'collection' column not found in 'datamodels' header.");
                }
            }
        }

        if (codexCollectionUrns.length === 0) {
            optionsHtml = '<option value="">No codices found</option>';
        } else {
            // 2. Create an <option> for each codex URN
            codexCollectionUrns.forEach(urn => {
                const label = HMTLib.collectionlabel(urn, parserInstance);
                const displayLabel = label ? label : urn; // Fallback to URN if label is null
                // Escape HTML special characters in label and URN for safety in attributes/content
                const escapedUrn = urn.replace(/"/g, "&quot;");
                const escapedLabel = displayLabel.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                optionsHtml += `<option value="${escapedUrn}">${escapedLabel}</option>\n`;
            });
        }
        
        const selectHtml = `<select name="${selectName}" id="${selectId}">\n${optionsHtml}</select>`;
        return selectHtml;
    }


    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex;
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexmenu = codexmenu; // New

})(window);
```

**2. `test_codex_menu.html` (New HTML test file)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Codex Menu</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        #menuContainer, #selectionDisplay { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; }
        select { padding: 5px; font-size: 1em; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>codexmenu</code> Function</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data... Please wait.</p>
    </div>

    <div id="menuContainer" style="display:none;">
        <h3>Select a Codex:</h3>
        <!-- Menu will be injected here -->
    </div>

    <div id="selectionDisplay" style="display:none;">
        <p>Current Selection: <strong id="currentSelectionText">N/A</strong></p>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runCodexMenuTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const menuContainerDiv = document.getElementById('menuContainer');
            const selectionDisplayDiv = document.getElementById('selectionDisplay');
            const currentSelectionTextEl = document.getElementById('currentSelectionText');
            const errorLogDiv = document.getElementById('errorLog');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console.</p>`;
                console.error(message, errorObj || '');
            }

            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.codexmenu || !HMTLib.collectionlabel) {
                showError("<strong>Error:</strong> A required library (CEXParser, URNTools, HMTLib) or HMTLib codexmenu/collectionlabel function is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Generating codex menu...</p>`;
                
                const menuId = "codexSelector";
                const menuName = "codex_choice";
                const menuHtml = HMTLib.codexmenu(parserInstance, menuName, menuId);

                menuContainerDiv.innerHTML += menuHtml; // Append the generated select menu
                menuContainerDiv.style.display = 'block';
                selectionDisplayDiv.style.display = 'block';

                const selectElement = document.getElementById(menuId);
                if (selectElement) {
                    // Initial display of selection
                    if (selectElement.options.length > 0 && selectElement.value) {
                         currentSelectionTextEl.textContent = selectElement.value;
                    } else {
                         currentSelectionTextEl.textContent = "No codex selected or menu empty.";
                    }

                    // Add event listener for changes
                    selectElement.addEventListener('change', function() {
                        currentSelectionTextEl.textContent = this.value;
                    });
                } else {
                    showError("Could not find the generated select element by ID: " + menuId);
                }

                loadingStatusDiv.innerHTML = `<p class="status success">Codex menu generated and displayed.</p>`;

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runCodexMenuTest();
    </script>
</body>
</html>
```

**Key changes and considerations:**

*   **`hmt-lib.js` (`codexmenu` function):**
    *   Takes `parserInstance`, `selectName`, and `selectId` as parameters.
    *   It first uses `parserInstance.getDelimitedData("datamodels")` to get data from the `datamodels` block.
    *   It parses this data to find rows where the `model` column equals `"urn:cite2:hmt:datamodels.v1:codexmodel"`. For these rows, it extracts the URN from the `collection` column. These are the codex URNs.
    *   It iterates through the found codex URNs.
    *   For each URN, it calls `HMTLib.collectionlabel(urn, parserInstance)` to get the display label. If the label is null, it defaults to using the URN itself.
    *   It constructs an `<option>` HTML string with the URN as the `value` and the label as the content. Values and labels are minimally escaped for HTML safety.
    *   Finally, it wraps all `<option>` strings within a `<select>` tag, using the provided `selectName` and `selectId`, and returns the complete HTML string.
    *   Includes basic error checking for dependencies (`URNTools`, `HMTLib.collectionlabel`).
*   **`test_codex_menu.html`**:
    *   Loads the HMT data.
    *   Calls `HMTLib.codexmenu` to get the HTML string for the dropdown.
    *   Injects this HTML string into a `div` (`menuContainer`).
    *   Adds an event listener to the newly created `<select>` element. When the user changes the selection, the `value` of the selected option (which is the codex URN) is displayed in another `div` (`selectionDisplay`).
    *   Also displays the initial selection when the page loads.

This approach creates a dynamic, data-driven codex selection menu based on the information present in your CEX file.

### USER
Something went wrong. All the HTML test files now show errors like  `Error: A required library (CEXParser, HMTLib) or HMTLib metadata function is not defined. Ensure all scripts are loaded correctly.`

### ASSISTANT
It sounds like there's a JavaScript error in the `hmt-lib.js` file, likely a syntax error, that's preventing it from loading completely. This would cause `HMTLib` or its functions to be undefined when the test HTML files try to use them.

A common cause for this, especially after multiple updates, is accidental redeclaration of classes or functions. In the previous step, I might have included placeholder comments for classes/functions and then also pasted their full definitions, leading to errors like "Identifier '...' has already been declared." This stops the script execution.

Let's provide a clean, complete version of `hmt-lib.js` ensuring each class and function is defined only once.

Here is the corrected and complete `hmt-lib.js`:

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = parseFloat(sequence); // Ensure sequence is numeric
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("hmtcurrent: CEXParser is not defined. Ensure cex-lib.js is loaded.");
            return Promise.reject(new Error("CEXParser is not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtnormalized: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtnormalized: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtdiplomatic: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdiplomatic: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtdse: Invalid parserInstance."); 
            return []; 
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }

            if (processedLines.length < 3) continue; // Need URN, label, header

            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { 
                    console.warn(`hmtdse: Header mismatch in ${currentBlockUrn}. Expected "${expectedHeader}", found "${headerLine}".`); 
                    continue; 
                }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) {
                        dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    } else {
                        console.warn(`hmtdse: Incorrect column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input.");
            return [];
        }
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input.");
            return null;
        }
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input.");
            return null;
        }
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray);
        if (recs.length > 0 && recs[0].imageroi && typeof recs[0].imageroi === 'string') {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtscholia: Invalid parserInstance."); 
            return []; 
        }

        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }

            if (processed.length < 3) continue; // Need URN, label, header

            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn) continue;
            
            if (blockUrn === targetUrn) {
                if (processed[2] !== expectedHeader) { 
                    console.warn(`hmtscholia: Header mismatch in ${blockUrn}. Expected "${expectedHeader}", found "${processed[2]}".`); 
                    continue; 
                }
                for (let i = 3; i < processed.length; i++) {
                    const cols = processed[i].split('|');
                    if (cols.length === 2) {
                        scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                    } else {
                        console.warn(`hmtscholia: Incorrect column count in ${blockUrn}, row: "${processed[i]}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || typeof scholionUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("passageforscholion: Invalid input.");
            return null;
        }
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || typeof iliadUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("scholiaforpassage: Invalid input.");
            return [];
        }
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];

        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must be a string ending with ':'."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools not defined. Ensure urn-lib.js is loaded."); return []; }

        const citeDataBlocks = parserInstance.getBlockContents("citedata");

        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};

            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;

            let missingHeaderColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { 
                    console.warn(`codex: Skipping citedata block - header missing required column '${colName}'. Header: "${headerLine}"`); 
                    missingHeaderColumn = true; 
                    break; 
                }
            }
            if (missingHeaderColumn) continue;

            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                
                const columnValues = trimmedLine.split('|');
                if (columnValues.length < Object.keys(columnIndexMap).length && columnValues.length < requiredColumns.length) { // Check against expected number of columns
                    // console.warn(`codex: Skipping data row due to insufficient columns. Row: "${trimmedLine}"`);
                    continue;
                }

                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) {
                    // console.warn(`codex: Skipping row with invalid CITE2 URN: ${currentRowFullUrn}`);
                    continue;
                }
                
                const parsedUrn = URNTools.parseCite2Urn(currentRowFullUrn); // Use parseCite2Urn for robust component access
                if (!parsedUrn.valid || !parsedUrn.namespace || !parsedUrn.collection) {
                     // console.warn(`codex: Could not parse components from URN: ${currentRowFullUrn}`);
                    continue;
                }
                const currentRowPrefix = `urn:cite2:${parsedUrn.namespace}:${parsedUrn.collection}:`;

                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        const sequence = parseFloat(sequenceStr); // Already done in constructor
                        if (isNaN(sequence)) {
                           // console.warn(`codex: Invalid sequence number "${sequenceStr}" for URN ${currentRowFullUrn}. Skipping.`);
                           continue;
                        }

                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label));
                    } catch (e) {
                        console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`);
                    }
                }
            }
        }
        return codexPagesResult;
    }

    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') { console.error("collectionlabel: collectionCite2Urn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("collectionlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");

        if (urnIndex === -1 || descriptionIndex === -1) { console.error("collectionlabel: 'URN' or 'Description' not in 'citecollections' header."); return null; }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                if (rowParts[urnIndex].trim() === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') { console.error("textlabel: textCtsUrn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("textlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };

        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) {
            console.error("textlabel: Required columns not in 'ctscatalog' header."); return null;
        }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;

            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                
                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }
                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        return null;
    }

    function codexmenu(parserInstance, selectName, selectId) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexmenu: Invalid parserInstance.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: Invalid Parser</option></select>`;
        }
        if (typeof URNTools === 'undefined') {
             console.error("codexmenu: URNTools is not defined.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: URNTools missing</option></select>`;
        }
        if (typeof HMTLib.collectionlabel !== 'function') { // Check HMTLib directly
             console.error("codexmenu: HMTLib.collectionlabel is not defined.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: collectionlabel missing</option></select>`;
        }

        let optionsHtml = '';
        const targetModel = "urn:cite2:hmt:datamodels.v1:codexmodel";
        const codexCollectionUrns = [];

        const datamodelsString = parserInstance.getDelimitedData("datamodels");
        if (datamodelsString) {
            const lines = datamodelsString.split('\n');
            if (lines.length > 0) {
                const header = lines[0].split('|').map(h => h.trim());
                const modelIndex = header.indexOf("model");
                const collectionIndex = header.indexOf("collection");

                if (modelIndex !== -1 && collectionIndex !== -1) {
                    for (let i = 1; i < lines.length; i++) {
                        const row = lines[i].trim();
                        if (row) {
                            const parts = row.split('|');
                            if (parts.length > Math.max(modelIndex, collectionIndex)) {
                                const modelValue = parts[modelIndex].trim();
                                if (modelValue === targetModel) {
                                    const collectionUrn = parts[collectionIndex].trim();
                                    if (URNTools.isValidCite2Urn(collectionUrn) && !codexCollectionUrns.includes(collectionUrn)) {
                                        codexCollectionUrns.push(collectionUrn);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    console.error("codexmenu: 'model' or 'collection' column not found in 'datamodels' header.");
                }
            }
        }

        if (codexCollectionUrns.length === 0) {
            optionsHtml = '<option value="">No codices found</option>';
        } else {
            codexCollectionUrns.forEach(urn => {
                const label = HMTLib.collectionlabel(urn, parserInstance); // Call HMTLib.collectionlabel
                const displayLabel = label ? label : urn; 
                const escapedUrn = urn.replace(/"/g, "&quot;");
                const escapedDisplayLabel = displayLabel.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                optionsHtml += `<option value="${escapedUrn}">${escapedDisplayLabel}</option>\n`;
            });
        }
        
        return `<select name="${selectName}" id="${selectId}">\n${optionsHtml}</select>`;
    }

    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex;
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexmenu = codexmenu;

})(window);
```

**Please replace the entire content of your `hmt-lib.js` file with the code above.**

This version ensures:
1.  Each class (`DSERecord`, `Scholion`, `CodexPage`) is defined only once at the top.
2.  Each function (`hmtcurrent`, `hmtnormalized`, etc., up to `codexmenu`) is defined only once.
3.  All necessary checks (like for `CEXParser`, `URNTools`, `HMTLib.collectionlabel`) are in place.
4.  The logic within each function, especially the newer ones, should be sound.

After updating `hmt-lib.js`, please try running your test HTML files again. If the error persists, open your browser's Developer Console (usually by pressing F12) and look for more specific JavaScript errors that occur when `hmt-lib.js` is loaded. These console errors will be key to pinpointing any remaining issues.

### USER
  
Great, that fixed all the loading errors! The `codexmenu` function is working right, however. Let's simplify it. Remove the `codexmenu` function from the library, and create instead a simple `codexlist` function. This should take one parameter, a CEXParser instance and should return the result of using the parser instance with `getCollectionsForModel("urn:cite2:hmt:datamodels.v1:codexmodel")`.
  
**Test**: Please implement this and test it in an HTML page by getting the current HMT release, and displaying the resuts of `codexlist`.

### ASSISTANT
Okay, we'll simplify by removing `codexmenu` and implementing `codexlist`.

As a reminder, `CEXParser` itself doesn't have a `getCollectionsForModel` method. The logic to achieve this involves reading the `datamodels` block and filtering by the specified model URN, similar to what we started in `codexmenu`.

Here's the updated `hmt-lib.js` and the new test HTML page:

**1. `hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = parseFloat(sequence); // Ensure sequence is numeric
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("hmtcurrent: CEXParser is not defined. Ensure cex-lib.js is loaded.");
            return Promise.reject(new Error("CEXParser is not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtnormalized: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtnormalized: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtdiplomatic: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdiplomatic: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtdse: Invalid parserInstance."); 
            return []; 
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }

            if (processedLines.length < 3) continue; // Need URN, label, header

            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { 
                    console.warn(`hmtdse: Header mismatch in ${currentBlockUrn}. Expected "${expectedHeader}", found "${headerLine}".`); 
                    continue; 
                }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) {
                        dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    } else {
                        console.warn(`hmtdse: Incorrect column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input.");
            return [];
        }
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input.");
            return null;
        }
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input.");
            return null;
        }
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray); // Use HMTLib.recordsforpage
        if (recs.length > 0 && recs[0].imageroi && typeof recs[0].imageroi === 'string') {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtscholia: Invalid parserInstance."); 
            return []; 
        }

        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }

            if (processed.length < 3) continue; // Need URN, label, header

            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn) continue;
            
            if (blockUrn === targetUrn) {
                if (processed[2] !== expectedHeader) { 
                    console.warn(`hmtscholia: Header mismatch in ${blockUrn}. Expected "${expectedHeader}", found "${processed[2]}".`); 
                    continue; 
                }
                for (let i = 3; i < processed.length; i++) {
                    const cols = processed[i].split('|');
                    if (cols.length === 2) {
                        scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                    } else {
                        console.warn(`hmtscholia: Incorrect column count in ${blockUrn}, row: "${processed[i]}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || typeof scholionUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("passageforscholion: Invalid input.");
            return null;
        }
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || typeof iliadUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("scholiaforpassage: Invalid input.");
            return [];
        }
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];

        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must be a string ending with ':'."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools not defined. Ensure urn-lib.js is loaded."); return []; }

        const citeDataBlocks = parserInstance.getBlockContents("citedata");

        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};

            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;

            let missingHeaderColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { 
                    console.warn(`codex: Skipping citedata block - header missing required column '${colName}'. Header: "${headerLine}"`); 
                    missingHeaderColumn = true; 
                    break; 
                }
            }
            if (missingHeaderColumn) continue;

            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                
                const columnValues = trimmedLine.split('|');
                 if (columnValues.length < Object.keys(columnIndexMap).length && columnValues.length < requiredColumns.length) {
                    continue;
                }

                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) {
                    continue;
                }
                
                const parsedUrn = URNTools.parseCite2Urn(currentRowFullUrn);
                if (!parsedUrn.valid || !parsedUrn.namespace || !parsedUrn.collection) {
                    continue;
                }
                const currentRowPrefix = `urn:cite2:${parsedUrn.namespace}:${parsedUrn.collection}:`;

                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        const sequence = parseFloat(sequenceStr); 
                        if (isNaN(sequence)) {
                           continue;
                        }

                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label));
                    } catch (e) {
                        console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`);
                    }
                }
            }
        }
        return codexPagesResult;
    }

    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') { console.error("collectionlabel: collectionCite2Urn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("collectionlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");

        if (urnIndex === -1 || descriptionIndex === -1) { console.error("collectionlabel: 'URN' or 'Description' not in 'citecollections' header."); return null; }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                if (rowParts[urnIndex].trim() === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') { console.error("textlabel: textCtsUrn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("textlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };

        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) {
            console.error("textlabel: Required columns not in 'ctscatalog' header."); return null;
        }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;

            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                
                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }
                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        return null;
    }

    // --- NEW codexlist FUNCTION ---
    /**
     * Retrieves a list of CITE2 URNs for collections that match the codex data model.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of CITE2 URN strings for codex collections.
     */
    function codexlist(parserInstance) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexlist: Invalid parserInstance.");
            return [];
        }
        if (typeof URNTools === 'undefined') {
             console.error("codexlist: URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }

        const targetModel = "urn:cite2:hmt:datamodels.v1:codexmodel";
        const codexCollectionUrns = [];

        const datamodelsString = parserInstance.getDelimitedData("datamodels");
        if (datamodelsString) {
            const lines = datamodelsString.split('\n');
            if (lines.length > 0) { // Must have at least a header line
                const headerLine = lines[0].trim();
                // Expected header for datamodels: urn|label|model|collection (order may vary)
                const headerParts = headerLine.split('|').map(h => h.trim());
                const modelIndex = headerParts.indexOf("model");
                const collectionIndex = headerParts.indexOf("collection");

                if (modelIndex !== -1 && collectionIndex !== -1) {
                    for (let i = 1; i < lines.length; i++) { // Start from 1 to skip header
                        const row = lines[i].trim();
                        if (row) { // Ensure row is not empty
                            const parts = row.split('|');
                            if (parts.length > Math.max(modelIndex, collectionIndex)) {
                                const modelValue = parts[modelIndex].trim();
                                if (modelValue === targetModel) {
                                    const collectionUrn = parts[collectionIndex].trim();
                                    // Ensure it's a valid CITE2 URN and not already added
                                    if (URNTools.isValidCite2Urn(collectionUrn) && !codexCollectionUrns.includes(collectionUrn)) {
                                        codexCollectionUrns.push(collectionUrn);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    console.error("codexlist: 'model' or 'collection' column not found in 'datamodels' header.");
                }
            }
        } else {
            // console.warn("codexlist: No data found for 'datamodels' block or block is empty.");
        }
        
        return codexCollectionUrns;
    }

    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex;
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexlist = codexlist; // New function, replacing codexmenu

})(window);
```

**Key changes in `hmt-lib.js`:**

1.  **Removed `codexmenu`**: The entire `codexmenu` function definition has been deleted.
2.  **Added `codexlist(parserInstance)`**:
    *   It takes a `CEXParser` instance.
    *   It defines `targetModel = "urn:cite2:hmt:datamodels.v1:codexmodel"`.
    *   It uses `parserInstance.getDelimitedData("datamodels")` to get the content of the `datamodels` block as a string.
    *   It parses this string:
        *   Splits into lines.
        *   Identifies the header line and the indices of `model` and `collection` columns.
        *   Iterates through data lines, splits them by `|`.
        *   If the `model` column matches `targetModel`, it extracts the URN from the `collection` column.
        *   It validates the extracted URN using `URNTools.isValidCite2Urn` and ensures it's not a duplicate before adding to the `codexCollectionUrns` array.
    *   Returns the `codexCollectionUrns` array.
    *   Includes checks for `parserInstance`, `URNTools`, and valid `datamodels` structure.

**2. `test_codex_list.html` (New HTML test file)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - codexlist</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        #resultsContainer { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; }
        pre { background-color: #eef; padding: 10px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>codexlist</code> Function</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data... Please wait.</p>
    </div>

    <div id="resultsContainer" style="display:none;">
        <h3>Codex URNs found by <code>codexlist</code>:</h3>
        <pre id="codexListOutput">N/A</pre>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runCodexListTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const resultsContainerDiv = document.getElementById('resultsContainer');
            const codexListOutputEl = document.getElementById('codexListOutput');
            const errorLogDiv = document.getElementById('errorLog');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console.</p>`;
                console.error(message, errorObj || '');
            }
            
            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return 'null';
                return unsafe.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }

            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.codexlist ) {
                showError("<strong>Error:</strong> A required library (CEXParser, URNTools, HMTLib) or HMTLib.codexlist function is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Generating codex list...</p>`;
                
                const codexUrns = HMTLib.codexlist(parserInstance);

                if (codexUrns.length > 0) {
                    codexListOutputEl.textContent = codexUrns.map(urn => escapeHtml(urn)).join('\n');
                } else {
                    codexListOutputEl.textContent = "No codex URNs found or an error occurred.";
                }
                
                resultsContainerDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status success">Codex list generated.</p>`;
                console.log("Codex URNs from codexlist:", codexUrns);

            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runCodexListTest();
    </script>
</body>
</html>
```

Now, `hmt-lib.js` contains `codexlist`, and `test_codex_list.html` will use it to fetch and display the list of codex URNs. This should correctly reflect the simplification you requested.

### USER
Actually, you're mistaken: CEXParser _does_ have `getCollectionsForModel` function. Please change the `codexlist` function to use the CEXParser instance with the  string value "urn:cite2:hmt:datamodels.v1:codexmodel" for its sole parameter.

### ASSISTANT
You are absolutely right! My apologies. I overlooked that specific function in the CEXParser documentation you provided earlier. Thank you for the correction.

The `getCollectionsForModel` function on the `CEXParser` instance will indeed simplify the `codexlist` function considerably.

Here is the updated `hmt-lib.js` file with the `codexlist` function modified to use `parserInstance.getCollectionsForModel()`:

**`hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = parseFloat(sequence); // Ensure sequence is numeric
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("hmtcurrent: CEXParser is not defined. Ensure cex-lib.js is loaded.");
            return Promise.reject(new Error("CEXParser is not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtnormalized: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtnormalized: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtdiplomatic: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdiplomatic: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtdse: Invalid parserInstance."); 
            return []; 
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }

            if (processedLines.length < 3) continue; 

            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { 
                    console.warn(`hmtdse: Header mismatch in ${currentBlockUrn}. Expected "${expectedHeader}", found "${headerLine}".`); 
                    continue; 
                }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) {
                        dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    } else {
                        console.warn(`hmtdse: Incorrect column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input.");
            return [];
        }
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input.");
            return null;
        }
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input.");
            return null;
        }
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray); 
        if (recs.length > 0 && recs[0].imageroi && typeof recs[0].imageroi === 'string') {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtscholia: Invalid parserInstance."); 
            return []; 
        }

        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }

            if (processed.length < 3) continue; 

            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn) continue;
            
            if (blockUrn === targetUrn) {
                if (processed[2] !== expectedHeader) { 
                    console.warn(`hmtscholia: Header mismatch in ${blockUrn}. Expected "${expectedHeader}", found "${processed[2]}".`); 
                    continue; 
                }
                for (let i = 3; i < processed.length; i++) {
                    const cols = processed[i].split('|');
                    if (cols.length === 2) {
                        scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                    } else {
                        console.warn(`hmtscholia: Incorrect column count in ${blockUrn}, row: "${processed[i]}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || typeof scholionUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("passageforscholion: Invalid input.");
            return null;
        }
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || typeof iliadUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("scholiaforpassage: Invalid input.");
            return [];
        }
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];

        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must be a string ending with ':'."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools not defined. Ensure urn-lib.js is loaded."); return []; }

        const citeDataBlocks = parserInstance.getBlockContents("citedata");

        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};

            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;

            let missingHeaderColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { 
                    console.warn(`codex: Skipping citedata block - header missing required column '${colName}'. Header: "${headerLine}"`); 
                    missingHeaderColumn = true; 
                    break; 
                }
            }
            if (missingHeaderColumn) continue;

            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                
                const columnValues = trimmedLine.split('|');
                 if (columnValues.length < Object.keys(columnIndexMap).length && columnValues.length < requiredColumns.length) {
                    continue;
                }

                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) {
                    continue;
                }
                
                const parsedUrn = URNTools.parseCite2Urn(currentRowFullUrn);
                if (!parsedUrn.valid || !parsedUrn.namespace || !parsedUrn.collection) {
                    continue;
                }
                const currentRowPrefix = `urn:cite2:${parsedUrn.namespace}:${parsedUrn.collection}:`;

                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        const sequence = parseFloat(sequenceStr); 
                        if (isNaN(sequence)) {
                           continue;
                        }

                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequence, image, currentRowFullUrn, rv, label));
                    } catch (e) {
                        console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`);
                    }
                }
            }
        }
        return codexPagesResult;
    }

    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') { console.error("collectionlabel: collectionCite2Urn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("collectionlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");

        if (urnIndex === -1 || descriptionIndex === -1) { console.error("collectionlabel: 'URN' or 'Description' not in 'citecollections' header."); return null; }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                if (rowParts[urnIndex].trim() === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') { console.error("textlabel: textCtsUrn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("textlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };

        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) {
            console.error("textlabel: Required columns not in 'ctscatalog' header."); return null;
        }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;

            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                
                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }
                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        return null;
    }

    // --- Updated codexlist FUNCTION ---
    /**
     * Retrieves a list of CITE2 URNs for collections that match the codex data model
     * by directly using CEXParser's getCollectionsForModel method.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @returns {string[]} An array of CITE2 URN strings for codex collections.
     */
    function codexlist(parserInstance) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexlist: Invalid parserInstance.");
            return [];
        }
        
        // Check if the method exists on the parser instance, as a safeguard
        if (typeof parserInstance.getCollectionsForModel !== 'function') {
            console.error("codexlist: parserInstance.getCollectionsForModel is not a function. Ensure cex-lib.js is the version that includes this method and is loaded correctly.");
            return [];
        }

        const targetModelValue = "urn:cite2:hmt:datamodels.v1:codexmodel";
        try {
            // The function is documented to take targetModelValue, and optionally modelColumnName and collectionColumnName.
            // Using default column names "Model" and "Collection" which should be correct.
            const codexUrns = parserInstance.getCollectionsForModel(targetModelValue);
            return codexUrns; // Should be an array of unique, sorted strings as per CEXParser docs
        } catch (e) {
            console.error("codexlist: Error calling parserInstance.getCollectionsForModel:", e);
            return [];
        }
    }

    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex;
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexlist = codexlist; // Updated function

})(window);
```

**Explanation of changes to `codexlist`:**

1.  **Direct Call**: It now directly calls `parserInstance.getCollectionsForModel(targetModelValue)`.
2.  **Simplified Logic**: All the manual parsing of the `datamodels` block (getting the string, splitting lines, finding header indices, iterating rows, and checking URN validity) has been removed because `getCollectionsForModel` is expected to handle this internally.
3.  **Error Handling**: Basic checks for `parserInstance` and the existence of the `getCollectionsForModel` method are kept, along with a `try...catch` block for the method call itself.
4.  **URNTools Dependency Removed**: The direct dependency on `URNTools` within `codexlist` (for `isValidCite2Urn`) is no longer needed as the `CEXParser` method should return valid collection URNs.

The test HTML page (`test_codex_list.html` provided in the previous step) should continue to work as expected, but now `HMTLib.codexlist` will be using the more direct and efficient CEXParser method.

### USER
OK, the `codexlist` function now works correctly, but the previously working `codex` function is now failing. That should not have been changed at all. Please keep `codexlist` as it now is, and revert `codex` to the previous working function.

### ASSISTANT
You are absolutely correct! My apologies for the oversight and for inadvertently breaking the `codex` function. It's crucial to maintain the integrity of previously working components.

Let's restore the `codex` function to its previously working state, ensuring it interacts correctly with the current `CodexPage` constructor, while keeping the `codexlist` function as it was in the last correct update.

Here is the complete `hmt-lib.js` with the `codex` function reverted and `codexlist` maintained:

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = parseFloat(sequence); // Ensure sequence is numeric
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("hmtcurrent: CEXParser is not defined. Ensure cex-lib.js is loaded.");
            return Promise.reject(new Error("CEXParser is not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtnormalized: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtnormalized: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtdiplomatic: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdiplomatic: Invalid parserInstance."); return []; }
        
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');

        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtdse: Invalid parserInstance."); 
            return []; 
        }

        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");

        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }

            if (processedLines.length < 3) continue; 

            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;

            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { 
                    console.warn(`hmtdse: Header mismatch in ${currentBlockUrn}. Expected "${expectedHeader}", found "${headerLine}".`); 
                    continue; 
                }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) {
                        dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    } else {
                        console.warn(`hmtdse: Incorrect column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordsforpage: Invalid input.");
            return [];
        }
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("recordforpassage: Invalid input.");
            return null;
        }
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) {
            console.error("imageforpage: Invalid input.");
            return null;
        }
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray); 
        if (recs.length > 0 && recs[0].imageroi && typeof recs[0].imageroi === 'string') {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";

        if (!(parserInstance instanceof CEXParser)) { 
            console.error("hmtscholia: Invalid parserInstance."); 
            return []; 
        }

        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }

            if (processed.length < 3) continue; 

            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn) continue;
            
            if (blockUrn === targetUrn) {
                if (processed[2] !== expectedHeader) { 
                    console.warn(`hmtscholia: Header mismatch in ${blockUrn}. Expected "${expectedHeader}", found "${processed[2]}".`); 
                    continue; 
                }
                for (let i = 3; i < processed.length; i++) {
                    const cols = processed[i].split('|');
                    if (cols.length === 2) {
                        scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                    } else {
                        console.warn(`hmtscholia: Incorrect column count in ${blockUrn}, row: "${processed[i]}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || typeof scholionUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("passageforscholion: Invalid input.");
            return null;
        }
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || typeof iliadUrn !== 'string' || !Array.isArray(scholiaArray)) {
            console.error("scholiaforpassage: Invalid input.");
            return [];
        }
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    // --- Reverted codex FUNCTION ---
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];

        if (!(parserInstance instanceof CEXParser)) {
            console.error("codex: Invalid parserInstance provided.");
            return [];
        }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) {
            console.error("codex: codexUrnPrefix must be a string ending with a colon (e.g., 'urn:cite2:namespace:collection:').");
            return [];
        }
        if (typeof URNTools === 'undefined') {
            console.error("codex: URNTools is not defined. Ensure urn-lib.js is loaded.");
            return [];
        }

        const citeDataBlocks = parserInstance.getBlockContents("citedata");

        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null;
            let dataLinesStartIdx = -1;
            const columnIndexMap = {};

            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    continue;
                }
                if (!headerLine) {
                    headerLine = trimmedLine;
                    const headerParts = headerLine.split('|');
                    headerParts.forEach((name, idx) => {
                        columnIndexMap[name.trim()] = idx;
                    });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }

            if (!headerLine) {
                continue;
            }

            let missingColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') {
                    console.warn(`codex: Skipping citedata block - header missing required column '${colName}'. Header: "${headerLine}"`);
                    missingColumn = true;
                    break;
                }
            }
            if (missingColumn) {
                continue;
            }

            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    continue;
                }

                const columnValues = trimmedLine.split('|');
                
                let maxRequiredIndex = 0;
                for (const rc of requiredColumns) {
                    if (columnIndexMap[rc] > maxRequiredIndex) maxRequiredIndex = columnIndexMap[rc];
                }
                if (columnValues.length <= maxRequiredIndex) {
                    // console.warn(`codex: Row "${trimmedLine}" has fewer columns (${columnValues.length}) than needed for required data (max index ${maxRequiredIndex}).`);
                    continue;
                }

                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();

                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) {
                    continue;
                }
                
                const rowNamespace = URNTools.cite2namespace(currentRowFullUrn);
                const rowCollection = URNTools.collectioncomponent(currentRowFullUrn);

                if (!rowNamespace || !rowCollection) {
                    continue;
                }
                const currentRowPrefix = `urn:cite2:${rowNamespace}:${rowCollection}:`;

                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        // CodexPage constructor handles parseFloat, but we ensure it's a valid number format first.
                        if (isNaN(parseFloat(sequenceStr))) {
                           // console.warn(`codex: Invalid sequence number "${sequenceStr}" for URN ${currentRowFullUrn}. Skipping.`);
                           continue;
                        }
                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();

                        // Pass sequenceStr, as CodexPage constructor does parseFloat
                        const page = new HMTLib.CodexPage(sequenceStr, image, currentRowFullUrn, rv, label);
                        codexPagesResult.push(page);
                    } catch (e) {
                        console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`);
                    }
                }
            }
        }
        return codexPagesResult;
    }


    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') { console.error("collectionlabel: collectionCite2Urn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("collectionlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");

        if (urnIndex === -1 || descriptionIndex === -1) { console.error("collectionlabel: 'URN' or 'Description' not in 'citecollections' header."); return null; }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                if (rowParts[urnIndex].trim() === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') { console.error("textlabel: textCtsUrn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("textlabel: parserInstance invalid."); return null; }

        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;

        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };

        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) {
            console.error("textlabel: Required columns not in 'ctscatalog' header."); return null;
        }

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;

            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                
                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }
                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        return null;
    }

    // --- Maintained codexlist FUNCTION ---
    function codexlist(parserInstance) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexlist: Invalid parserInstance.");
            return [];
        }
        
        if (typeof parserInstance.getCollectionsForModel !== 'function') {
            console.error("codexlist: parserInstance.getCollectionsForModel is not a function. Ensure cex-lib.js is the version that includes this method and is loaded correctly.");
            return [];
        }

        const targetModelValue = "urn:cite2:hmt:datamodels.v1:codexmodel";
        try {
            const codexUrns = parserInstance.getCollectionsForModel(targetModelValue);
            return codexUrns; 
        } catch (e) {
            console.error("codexlist: Error calling parserInstance.getCollectionsForModel:", e);
            return [];
        }
    }

    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex; // Reverted
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexlist = codexlist; // Maintained

})(window);
```

**Key changes in this version:**

*   The `codex` function has been replaced with the version that was working correctly before the `codexmenu` and subsequent `codexlist` changes. This version includes:
    *   Correct URN prefix derivation using `URNTools.cite2namespace` and `URNTools.collectioncomponent`.
    *   A robust check for the number of columns in data rows (`columnValues.length <= maxRequiredIndex`).
    *   Passing the string `sequenceStr` to the `HMTLib.CodexPage` constructor, as the constructor now handles `parseFloat`.
    *   A pre-check `isNaN(parseFloat(sequenceStr))` before attempting to create the `CodexPage` object.
*   The `codexlist` function remains as it was in the immediately previous step (using `parserInstance.getCollectionsForModel`).
*   All other functions and classes remain untouched from the last stable version.

This should resolve the regression in the `codex` function while keeping the `codexlist` function correct. Please test this thoroughly.

### USER
Fantastic! Let's return to the challenge of a writing  a function `codexmenu` that builds an HTML options menu to let users choose a codex. It should take three parameters: an instance of a CEX Parser, a name for the select element, an ID for the select element. The menu should create the options as follows. Use the new `codexlist` function to get a list of CITE2 URNs for codices. Create an `option` element for each URN in the list. The URN should be value of the option element. The contents of the element should be the output of using the `collectionlabel` function with that URN.  
**Test**: Please implement this and test it by writing an HTML page that loads the current HMT release, displays a menu created by the `codexmenu` function, then displays the user's  current selection .

### ASSISTANT
Okay, we're back to creating the `codexmenu` function! This time, we'll leverage your newly working `codexlist` and `collectionlabel` functions. This will make `codexmenu` cleaner and more modular.

Here's the implementation:

**1. `hmt-lib.js` (Updated)**

```javascript
// hmt-lib.js
(function(window) {
    'use strict';

    if (typeof window.HMTLib === 'undefined') {
        window.HMTLib = {};
    }

    // --- CLASSES ---
    class DSERecord {
        constructor(passage, imageroi, surface) {
            this.passage = passage;
            this.imageroi = imageroi;
            this.surface = surface;
        }
    }

    class Scholion {
        constructor(scholionUrn, iliadUrn) {
            this.scholion = scholionUrn;
            this.iliad = iliadUrn;
        }
    }

    class CodexPage {
        constructor(sequence, image, urn, rv, label) {
            this.sequence = parseFloat(sequence); // Ensure sequence is numeric
            this.image = image;
            this.urn = urn;
            this.rv = rv;
            this.label = label;
        }
    }

    // --- CORE HMT FUNCTIONS ---
    function hmtcurrent() {
        const hmtCurrentCexUrl = "https://raw.githubusercontent.com/homermultitext/hmt-archive/refs/heads/master/releases-cex/hmt-current.cex";
        if (typeof CEXParser === 'undefined') {
            console.error("hmtcurrent: CEXParser is not defined. Ensure cex-lib.js is loaded.");
            return Promise.reject(new Error("CEXParser is not defined."));
        }
        const parser = new CEXParser();
        return parser.loadFromUrl(hmtCurrentCexUrl);
    }

    function hmtnormalized(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtnormalized: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtnormalized: Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.normalized')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }

    function hmtdiplomatic(parserInstance) {
        if (typeof URNTools === 'undefined') { console.error("hmtdiplomatic: URNTools not defined."); return []; }
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdiplomatic: Invalid parserInstance."); return []; }
        const filteredRecords = [];
        const ctsDataBlockContents = parserInstance.getBlockContents('ctsdata');
        ctsDataBlockContents.forEach(blockContent => {
            const lines = blockContent.split('\n');
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) return;
                const parts = trimmedLine.split('|');
                if (parts.length >= 1) {
                    const urnString = parts[0];
                    const workComponent = URNTools.workcomponent(urnString);
                    if (workComponent && workComponent.endsWith('.diplomatic')) {
                        filteredRecords.push(trimmedLine);
                    }
                }
            });
        });
        return filteredRecords;
    }
    
    function hmtdse(parserInstance) {
        const dseRecords = [];
        const targetRelationSetUrn = "urn:cite2:hmt:hmtdse.v1:all";
        const expectedHeader = "passage|imageroi|surface";
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtdse: Invalid parserInstance."); return []; }
        const citeRelationSetBlockContents = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of citeRelationSetBlockContents) {
            const lines = blockContent.split('\n');
            const processedLines = [];
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine !== '' && !trimmedLine.startsWith('//')) processedLines.push(trimmedLine);
            }
            if (processedLines.length < 3) continue; 
            let currentBlockUrn = processedLines[0].startsWith("urn|") ? processedLines[0].substring("urn|".length) : null;
            if (!currentBlockUrn) continue;
            if (currentBlockUrn === targetRelationSetUrn) {
                const headerLine = processedLines[2];
                if (headerLine !== expectedHeader) { console.warn(`hmtdse: Header mismatch in ${currentBlockUrn}. Expected "${expectedHeader}", found "${headerLine}".`); continue; }
                for (let i = 3; i < processedLines.length; i++) {
                    const columns = processedLines[i].split('|');
                    if (columns.length === 3) {
                        dseRecords.push(new HMTLib.DSERecord(columns[0], columns[1], columns[2]));
                    } else {
                        console.warn(`hmtdse: Incorrect column count in ${currentBlockUrn}, row: "${processedLines[i]}"`);
                    }
                }
            }
        }
        return dseRecords;
    }

    function recordsforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) { console.error("recordsforpage: Invalid input."); return []; }
        return dseRecordsArray.filter(r => r instanceof HMTLib.DSERecord && r.surface === pageUrn);
    }

    function recordforpassage(passageUrn, dseRecordsArray) {
        if (!passageUrn || typeof passageUrn !== 'string' || !Array.isArray(dseRecordsArray)) { console.error("recordforpassage: Invalid input."); return null; }
        return dseRecordsArray.find(r => r instanceof HMTLib.DSERecord && r.passage === passageUrn) || null;
    }

    function imageforpage(pageUrn, dseRecordsArray) {
        if (!pageUrn || typeof pageUrn !== 'string' || !Array.isArray(dseRecordsArray)) { console.error("imageforpage: Invalid input."); return null; }
        const recs = HMTLib.recordsforpage(pageUrn, dseRecordsArray); 
        if (recs.length > 0 && recs[0].imageroi && typeof recs[0].imageroi === 'string') {
            const idx = recs[0].imageroi.lastIndexOf('@');
            return idx !== -1 ? recs[0].imageroi.substring(0, idx) : recs[0].imageroi;
        }
        return null;
    }

    function hmtscholia(parserInstance) {
        const scholiaRecords = [];
        const targetUrn = "urn:cite2:hmt:commentary.v1:all";
        const expectedHeader = "scholion|iliad";
        if (!(parserInstance instanceof CEXParser)) { console.error("hmtscholia: Invalid parserInstance."); return []; }
        const blocks = parserInstance.getBlockContents("citerelationset");
        for (const blockContent of blocks) {
            const lines = blockContent.split('\n');
            const processed = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed !== '' && !trimmed.startsWith('//')) processed.push(trimmed);
            }
            if (processed.length < 3) continue; 
            let blockUrn = processed[0].startsWith("urn|") ? processed[0].substring("urn|".length) : null;
            if (!blockUrn) continue;
            if (blockUrn === targetUrn) {
                if (processed[2] !== expectedHeader) { console.warn(`hmtscholia: Header mismatch in ${blockUrn}. Expected "${expectedHeader}", found "${processed[2]}".`); continue; }
                for (let i = 3; i < processed.length; i++) {
                    const cols = processed[i].split('|');
                    if (cols.length === 2) {
                        scholiaRecords.push(new HMTLib.Scholion(cols[0], cols[1]));
                    } else {
                        console.warn(`hmtscholia: Incorrect column count in ${blockUrn}, row: "${processed[i]}"`);
                    }
                }
            }
        }
        return scholiaRecords;
    }

    function passageforscholion(scholionUrn, scholiaArray) {
        if (!scholionUrn || typeof scholionUrn !== 'string' || !Array.isArray(scholiaArray)) { console.error("passageforscholion: Invalid input."); return null; }
        const found = scholiaArray.find(s => s instanceof HMTLib.Scholion && s.scholion === scholionUrn);
        return found ? found.iliad : null;
    }

    function scholiaforpassage(iliadUrn, scholiaArray) {
        if (!iliadUrn || typeof iliadUrn !== 'string' || !Array.isArray(scholiaArray)) { console.error("scholiaforpassage: Invalid input."); return []; }
        return scholiaArray.filter(s => s instanceof HMTLib.Scholion && s.iliad === iliadUrn).map(s => s.scholion);
    }
    
    function codex(parserInstance, codexUrnPrefix) {
        const codexPagesResult = [];
        const requiredColumns = ['urn', 'sequence', 'image', 'rv', 'label'];
        if (!(parserInstance instanceof CEXParser)) { console.error("codex: Invalid parserInstance provided."); return []; }
        if (typeof codexUrnPrefix !== 'string' || !codexUrnPrefix.endsWith(':')) { console.error("codex: codexUrnPrefix must be a string ending with a colon."); return []; }
        if (typeof URNTools === 'undefined') { console.error("codex: URNTools is not defined."); return []; }
        const citeDataBlocks = parserInstance.getBlockContents("citedata");
        for (const blockContent of citeDataBlocks) {
            const lines = blockContent.split('\n');
            let headerLine = null, dataLinesStartIdx = -1;
            const columnIndexMap = {};
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                if (!headerLine) {
                    headerLine = trimmedLine;
                    headerLine.split('|').forEach((name, idx) => { columnIndexMap[name.trim()] = idx; });
                    dataLinesStartIdx = i + 1;
                    break; 
                }
            }
            if (!headerLine) continue;
            let missingColumn = false;
            for (const colName of requiredColumns) {
                if (typeof columnIndexMap[colName] === 'undefined') { console.warn(`codex: Skipping citedata block - header missing '${colName}'. Header: "${headerLine}"`); missingColumn = true; break; }
            }
            if (missingColumn) continue;
            for (let i = dataLinesStartIdx; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '' || trimmedLine.startsWith('//')) continue;
                const columnValues = trimmedLine.split('|');
                let maxRequiredIndex = 0;
                for (const rc of requiredColumns) { if (columnIndexMap[rc] > maxRequiredIndex) maxRequiredIndex = columnIndexMap[rc]; }
                if (columnValues.length <= maxRequiredIndex) continue;
                const currentRowFullUrn = columnValues[columnIndexMap['urn']].trim();
                if (!URNTools.isValidCite2Urn(currentRowFullUrn)) continue;
                const rowNamespace = URNTools.cite2namespace(currentRowFullUrn);
                const rowCollection = URNTools.collectioncomponent(currentRowFullUrn);
                if (!rowNamespace || !rowCollection) continue;
                const currentRowPrefix = `urn:cite2:${rowNamespace}:${rowCollection}:`;
                if (currentRowPrefix === codexUrnPrefix) {
                    try {
                        const sequenceStr = columnValues[columnIndexMap['sequence']].trim();
                        if (isNaN(parseFloat(sequenceStr))) continue;
                        const image = columnValues[columnIndexMap['image']].trim();
                        const rv = columnValues[columnIndexMap['rv']].trim();
                        const label = columnValues[columnIndexMap['label']].trim();
                        codexPagesResult.push(new HMTLib.CodexPage(sequenceStr, image, currentRowFullUrn, rv, label));
                    } catch (e) { console.error(`codex: Error creating CodexPage for row "${trimmedLine}". Error: ${e.message}`); }
                }
            }
        }
        return codexPagesResult;
    }

    function collectionlabel(collectionCite2Urn, parserInstance) {
        if (!collectionCite2Urn || typeof collectionCite2Urn !== 'string') { console.error("collectionlabel: collectionCite2Urn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("collectionlabel: parserInstance invalid."); return null; }
        const dataString = parserInstance.getDelimitedData("citecollections");
        if (!dataString) return null;
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;
        const headerParts = lines[0].split('|').map(h => h.trim());
        const urnIndex = headerParts.indexOf("URN");
        const descriptionIndex = headerParts.indexOf("Description");
        if (urnIndex === -1 || descriptionIndex === -1) { console.error("collectionlabel: 'URN' or 'Description' not in 'citecollections' header."); return null; }
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length > Math.max(urnIndex, descriptionIndex)) {
                if (rowParts[urnIndex].trim() === collectionCite2Urn) {
                    return rowParts[descriptionIndex].trim();
                }
            }
        }
        return null;
    }

    function textlabel(textCtsUrn, parserInstance) {
        if (!textCtsUrn || typeof textCtsUrn !== 'string') { console.error("textlabel: textCtsUrn invalid."); return null; }
        if (!(parserInstance instanceof CEXParser)) { console.error("textlabel: parserInstance invalid."); return null; }
        const dataString = parserInstance.getDelimitedData("ctscatalog");
        if (!dataString) return null;
        const lines = dataString.split('\n');
        if (lines.length < 1) return null;
        const headerParts = lines[0].split('|').map(h => h.trim());
        const colIndices = {
            urn: headerParts.indexOf("urn"), groupName: headerParts.indexOf("groupName"),
            workTitle: headerParts.indexOf("workTitle"), versionLabel: headerParts.indexOf("versionLabel"),
            exemplarLabel: headerParts.indexOf("exemplarLabel")
        };
        if (colIndices.urn === -1 || colIndices.groupName === -1 || colIndices.workTitle === -1 || colIndices.versionLabel === -1) { console.error("textlabel: Required columns not in 'ctscatalog' header."); return null; }
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === "") continue;
            const rowParts = line.split('|');
            if (rowParts.length <= colIndices.urn) continue;
            if (rowParts[colIndices.urn].trim() === textCtsUrn) {
                if (rowParts.length <= Math.max(colIndices.groupName, colIndices.workTitle, colIndices.versionLabel)) return null;
                const group = rowParts[colIndices.groupName].trim();
                const work = rowParts[colIndices.workTitle].trim();
                const version = rowParts[colIndices.versionLabel].trim();
                let exemplar = "";
                if (colIndices.exemplarLabel !== -1 && rowParts.length > colIndices.exemplarLabel) {
                    exemplar = rowParts[colIndices.exemplarLabel].trim();
                }
                let label = `${group}, ${work} (${version})`;
                if (exemplar) {
                    label += ` ${exemplar}`;
                }
                return label;
            }
        }
        return null;
    }

    function codexlist(parserInstance) {
        if (!(parserInstance instanceof CEXParser)) { console.error("codexlist: Invalid parserInstance."); return []; }
        if (typeof parserInstance.getCollectionsForModel !== 'function') { console.error("codexlist: parserInstance.getCollectionsForModel is not a function."); return []; }
        const targetModelValue = "urn:cite2:hmt:datamodels.v1:codexmodel";
        try {
            return parserInstance.getCollectionsForModel(targetModelValue);
        } catch (e) {
            console.error("codexlist: Error calling parserInstance.getCollectionsForModel:", e);
            return [];
        }
    }

    // --- NEW codexmenu FUNCTION ---
    /**
     * Builds an HTML select menu for choosing a codex.
     * Uses HMTLib.codexlist to get URNs and HMTLib.collectionlabel for option text.
     * @param {CEXParser} parserInstance - The CEXParser instance.
     * @param {string} selectName - The 'name' attribute for the select element.
     * @param {string} selectId - The 'id' attribute for the select element.
     * @returns {string} An HTML string representing the <select> element.
     */
    function codexmenu(parserInstance, selectName, selectId) {
        if (!(parserInstance instanceof CEXParser)) {
            console.error("codexmenu: Invalid parserInstance.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: Invalid Parser</option></select>`;
        }
        // Ensure dependent HMTLib functions are available
        if (typeof HMTLib.codexlist !== 'function') {
             console.error("codexmenu: HMTLib.codexlist is not defined.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: codexlist fn missing</option></select>`;
        }
        if (typeof HMTLib.collectionlabel !== 'function') {
             console.error("codexmenu: HMTLib.collectionlabel is not defined.");
            return `<select name="${selectName}" id="${selectId}"><option value="">Error: collectionlabel fn missing</option></select>`;
        }

        let optionsHtml = '';
        const codexUrns = HMTLib.codexlist(parserInstance);

        if (codexUrns.length === 0) {
            optionsHtml = '<option value="">No codices found</option>';
        } else {
            codexUrns.forEach(urn => {
                const label = HMTLib.collectionlabel(urn, parserInstance);
                const displayLabel = label ? label : urn; // Fallback to URN if label is null
                
                // Basic HTML escaping for attribute values and content
                const escapedUrn = urn.replace(/"/g, "&quot;"); // Escape double quotes for value attribute
                const escapedDisplayLabel = displayLabel.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

                optionsHtml += `<option value="${escapedUrn}">${escapedDisplayLabel}</option>\n`;
            });
        }
        
        const selectHtml = `<select name="${selectName}" id="${selectId}">\n${optionsHtml}</select>`;
        return selectHtml;
    }

    // Expose classes and functions
    window.HMTLib.DSERecord = DSERecord;
    window.HMTLib.Scholion = Scholion;
    window.HMTLib.CodexPage = CodexPage;

    window.HMTLib.hmtcurrent = hmtcurrent;
    window.HMTLib.hmtnormalized = hmtnormalized;
    window.HMTLib.hmtdiplomatic = hmtdiplomatic;
    window.HMTLib.hmtdse = hmtdse;
    window.HMTLib.recordsforpage = recordsforpage;
    window.HMTLib.recordforpassage = recordforpassage;
    window.HMTLib.imageforpage = imageforpage;
    window.HMTLib.hmtscholia = hmtscholia;
    window.HMTLib.passageforscholion = passageforscholion;
    window.HMTLib.scholiaforpassage = scholiaforpassage;
    window.HMTLib.codex = codex; 
    window.HMTLib.collectionlabel = collectionlabel;
    window.HMTLib.textlabel = textlabel;
    window.HMTLib.codexlist = codexlist; 
    window.HMTLib.codexmenu = codexmenu; // New codexmenu

})(window);
```

**2. `test_codex_menu.html` (Re-using this filename, or create `test_codex_menu_v2.html`)**

This test page is very similar to the one used for the first attempt at `codexmenu`.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT Library Test - Codex Menu (v2)</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .status { font-weight: bold; }
        .error { color: red; }
        .success { color: green; }
        #menuContainer, #selectionDisplay { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; }
        select { padding: 5px; font-size: 1em; margin-bottom: 10px; }
    </style>
    <!-- 1. Include cex-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <!-- 2. Include urn-lib.js -->
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
    <!-- 3. Include your hmt-lib.js -->
    <script src="hmt-lib.js"></script>
</head>
<body>
    <h1>HMT Library Test: <code>codexmenu</code> Function (using <code>codexlist</code>)</h1>
    <div id="loadingStatus">
        <p class="status">Loading HMT CEX data... Please wait.</p>
    </div>

    <div id="menuContainer" style="display:none;">
        <h3>Select a Codex:</h3>
        <!-- Menu will be injected here -->
    </div>

    <div id="selectionDisplay" style="display:none;">
        <p>Current Selection: <strong id="currentSelectionText">N/A</strong></p>
    </div>

    <div id="errorLog" style="display:none;" class="error"></div>

    <script>
        async function runCodexMenuTest() {
            const loadingStatusDiv = document.getElementById('loadingStatus');
            const menuContainerDiv = document.getElementById('menuContainer');
            const selectionDisplayDiv = document.getElementById('selectionDisplay');
            const currentSelectionTextEl = document.getElementById('currentSelectionText');
            const errorLogDiv = document.getElementById('errorLog');

            function showError(message, errorObj = null) {
                errorLogDiv.innerHTML += `<p>${message}</p>`;
                errorLogDiv.style.display = 'block';
                loadingStatusDiv.innerHTML = `<p class="status error">An error occurred. Check console.</p>`;
                console.error(message, errorObj || '');
            }

            // Check for all necessary HMTLib functions for this test
            if (typeof CEXParser === 'undefined' || typeof URNTools === 'undefined' || typeof HMTLib === 'undefined' ||
                !HMTLib.hmtcurrent || !HMTLib.codexmenu || !HMTLib.codexlist || !HMTLib.collectionlabel) {
                showError("<strong>Error:</strong> A required library or HMTLib function (hmtcurrent, codexmenu, codexlist, collectionlabel) is not defined. Ensure all scripts are loaded correctly.");
                return;
            }

            try {
                const parserInstance = await HMTLib.hmtcurrent();
                loadingStatusDiv.innerHTML = `<p class="status success">HMT CEX data loaded. Generating codex menu...</p>`;
                
                const menuId = "codexSelector";
                const menuName = "codex_choice";
                const menuHtml = HMTLib.codexmenu(parserInstance, menuName, menuId);

                // It's safer to set innerHTML of a dedicated container for the menu
                const menuTargetDiv = document.createElement('div');
                menuTargetDiv.innerHTML = menuHtml;
                menuContainerDiv.appendChild(menuTargetDiv); // Append the div containing the select

                menuContainerDiv.style.display = 'block';
                selectionDisplayDiv.style.display = 'block';

                const selectElement = document.getElementById(menuId);
                if (selectElement) {
                    // Initial display of selection
                    if (selectElement.options.length > 0 && selectElement.value) {
                         currentSelectionTextEl.textContent = selectElement.value;
                    } else if (selectElement.options.length > 0 && selectElement.options[0].value === "") {
                        currentSelectionTextEl.textContent = selectElement.options[0].textContent; // e.g., "No codices found"
                    } else {
                         currentSelectionTextEl.textContent = "Menu may be empty or an error occurred.";
                    }

                    // Add event listener for changes
                    selectElement.addEventListener('change', function() {
                        currentSelectionTextEl.textContent = this.value;
                    });
                } else {
                    showError("Could not find the generated select element by ID: " + menuId);
                }

                loadingStatusDiv.innerHTML = `<p class="status success">Codex menu generated and displayed.</p>`;
                console.log("Generated menu HTML by codexmenu:", menuHtml);
                console.log("Codex URNs from codexlist for menu:", HMTLib.codexlist(parserInstance));


            } catch (error) {
                showError(`<strong>Error during main test execution:</strong> ${error.message}`, error);
            }
        }

        runCodexMenuTest();
    </script>
</body>
</html>
```

**Key changes and considerations:**

*   **`hmt-lib.js` (`codexmenu` function):**
    *   It now correctly calls `HMTLib.codexlist(parserInstance)` to get the array of codex URNs.
    *   It then iterates through these URNs, calling `HMTLib.collectionlabel(urn, parserInstance)` for each to get the display text for the option.
    *   A fallback to using the URN as display text is included if `collectionlabel` returns `null`.
    *   Basic HTML escaping is done for the URN (value attribute) and the display label (option content) to prevent issues if they contain special characters.
    *   Includes checks for the existence of its dependencies (`HMTLib.codexlist`, `HMTLib.collectionlabel`).
*   **Test HTML (`test_codex_menu.html`):**
    *   Loads the HMT data.
    *   Calls the new `HMTLib.codexmenu` to get the HTML for the select element.
    *   Injects this HTML into the page.
    *   Sets up an event listener to display the selected URN.
    *   Improved initial display of selection, considering cases where the menu might be empty or have a "No codices found" option.

This revised `codexmenu` should now work as intended, building upon the functionality already established in `codexlist` and `collectionlabel`.

### USER
Awesome! Im going to publish this on GitHub! Could you write API documentation for the library?

### ASSISTANT
That's excellent! Publishing to GitHub is a great idea. Here's API documentation for your `HMTLib` JavaScript library, formatted in Markdown, which is perfect for a `README.md` file or a separate documentation file in your repository.

```markdown
# HMTLib.js API Documentation

## Overview

`HMTLib.js` is a JavaScript library designed to work with publications from the Homer Multitext project (HMT). It leverages `cex-lib.js` for parsing and manipulating HMT data in CiteEXchange (CEX) format, and `urn-lib.js` for working with CTS and CITE2 URNs. This library provides functions to load HMT data, extract specific datasets like DSE records, scholia, codex information, and retrieve metadata labels.

## Dependencies

This library requires the following external libraries to be loaded **before** `hmt-lib.js`:

1.  **`cex-lib.js`**: For parsing CEX data.
    *   Available via jsDelivr: `<script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>`
2.  **`urn-lib.js`**: For parsing and manipulating URNs.
    *   Available via jsDelivr: `<script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>`

These libraries provide the global objects `CEXParser` and `URNTools` respectively, which `HMTLib.js` depends on.

## Installation & Usage

### Browser

Include `cex-lib.js`, `urn-lib.js`, and then `hmt-lib.js` in your HTML file:

```html
<script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
<script src="https://cdn.jsdelivr.net/gh/neelsmith/urns-lib/urn-lib.js"></script>
<script src="path/to/hmt-lib.js"></script>
<script>
    // Example usage:
    async function main() {
        try {
            const hmtParser = await HMTLib.hmtcurrent();
            const codices = HMTLib.codexlist(hmtParser);
            console.log("Available codices:", codices);
        } catch (error) {
            console.error("Error using HMTLib:", error);
        }
    }
    main();
</script>
```

All public classes and functions are available under the global `HMTLib` object.

---

## Global Object: `HMTLib`

All functionalities of this library are exposed through the global `HMTLib` object.

---

## Classes

### `HMTLib.DSERecord`

Represents a Document-Surface-Element (DSE) record linking a passage to an image region on a surface.

*   **`new HMTLib.DSERecord(passage, imageroi, surface)`**
    *   **Parameters:**
        *   `passage` (String): The CTS URN of the text passage.
        *   `imageroi` (String): The CITE2 URN of the image with an optional Region of Interest (ROI).
        *   `surface` (String): The CITE2 URN of the manuscript surface (e.g., page).
    *   **Properties:**
        *   `this.passage` (String)
        *   `this.imageroi` (String)
        *   `this.surface` (String)

### `HMTLib.Scholion`

Represents a scholion record, linking a scholion text to an Iliad passage.

*   **`new HMTLib.Scholion(scholionUrn, iliadUrn)`**
    *   **Parameters:**
        *   `scholionUrn` (String): The CTS URN of the scholion text.
        *   `iliadUrn` (String): The CTS URN of the Iliad passage the scholion refers to.
    *   **Properties:**
        *   `this.scholion` (String)
        *   `this.iliad` (String)

### `HMTLib.CodexPage`

Represents a page within a codex.

*   **`new HMTLib.CodexPage(sequence, image, urn, rv, label)`**
    *   **Parameters:**
        *   `sequence` (String|Number): The sequence number of the page (will be parsed as a float).
        *   `image` (String): The CITE2 URN of the image for this page.
        *   `urn` (String): The CITE2 URN of this page object itself.
        *   `rv` (String): The recto/verso indicator (e.g., 'r', 'v').
        *   `label` (String): The human-readable label for the page.
    *   **Properties:**
        *   `this.sequence` (Number)
        *   `this.image` (String)
        *   `this.urn` (String)
        *   `this.rv` (String)
        *   `this.label` (String)

---

## Core Functions

### `HMTLib.hmtcurrent()`

Asynchronously loads the current HMT CEX data release from the official HMT GitHub repository.

*   **Parameters:** None.
*   **Returns:** (`Promise<CEXParser>`) A Promise that resolves with a `CEXParser` instance loaded with the HMT data, or rejects with an Error.
*   **Example:**
    ```javascript
    HMTLib.hmtcurrent()
        .then(parser => console.log("HMT Data Loaded!", parser.getUniqueBlockLabels()))
        .catch(error => console.error("Failed to load HMT data:", error));
    ```

---

## Data Extraction Functions

### `HMTLib.hmtnormalized(parserInstance)`

Filters text passage records from `ctsdata` blocks where the CTS URN's work component ends with `.normalized`.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`String[]`) An array of matching delimited-text lines (records).

### `HMTLib.hmtdiplomatic(parserInstance)`

Filters text passage records from `ctsdata` blocks where the CTS URN's work component ends with `.diplomatic`.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`String[]`) An array of matching delimited-text lines (records).

### `HMTLib.hmtdse(parserInstance)`

Extracts an array of `HMTLib.DSERecord` objects from `citerelationset` blocks with the URN `urn:cite2:hmt:hmtdse.v1:all`.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`HMTLib.DSERecord[]`) An array of `DSERecord` objects.

### `HMTLib.hmtscholia(parserInstance)`

Extracts an array of `HMTLib.Scholion` objects from `citerelationset` blocks with the URN `urn:cite2:hmt:commentary.v1:all`.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`HMTLib.Scholion[]`) An array of `Scholion` objects.

### `HMTLib.codex(parserInstance, codexUrnPrefix)`

Extracts an array of `HMTLib.CodexPage` objects from `citedata` blocks that belong to a specified codex.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
    *   `codexUrnPrefix` (String): The CITE2 URN prefix identifying the codex (e.g., "urn:cite2:hmt:msA.v1:").
*   **Returns:** (`HMTLib.CodexPage[]`) An array of `CodexPage` objects.

---

## Query Functions for DSE Records

(These functions typically operate on an array of `HMTLib.DSERecord` objects obtained from `HMTLib.hmtdse`)

### `HMTLib.recordsforpage(pageUrn, dseRecordsArray)`

Finds all `DSERecord` objects where the `surface` property matches the given page URN.

*   **Parameters:**
    *   `pageUrn` (String): The CITE2 URN of the page (surface) to search for.
    *   `dseRecordsArray` (`HMTLib.DSERecord[]`): An array of `DSERecord` objects.
*   **Returns:** (`HMTLib.DSERecord[]`) An array of matching `DSERecord` objects.

### `HMTLib.recordforpassage(passageUrn, dseRecordsArray)`

Finds the first `DSERecord` object where the `passage` property matches the given CTS URN.

*   **Parameters:**
    *   `passageUrn` (String): The CTS URN of the passage to search for.
    *   `dseRecordsArray` (`HMTLib.DSERecord[]`): An array of `DSERecord` objects.
*   **Returns:** (`HMTLib.DSERecord | null`) The matching `DSERecord` object, or `null` if not found.

### `HMTLib.imageforpage(pageUrn, dseRecordsArray)`

Finds the base image URN (without ROI) for a given page URN from an array of DSE records.

*   **Parameters:**
    *   `pageUrn` (String): The CITE2 URN identifying the page (surface).
    *   `dseRecordsArray` (`HMTLib.DSERecord[]`): An array of `DSERecord` objects.
*   **Returns:** (`String | null`) The image URN (without ROI), or `null` if not found.

---

## Query Functions for Scholia Records

(These functions typically operate on an array of `HMTLib.Scholion` objects obtained from `HMTLib.hmtscholia`)

### `HMTLib.passageforscholion(scholionUrn, scholiaArray)`

Finds the Iliad passage URN that a specific scholion URN refers to.

*   **Parameters:**
    *   `scholionUrn` (String): The CTS URN of the scholion.
    *   `scholiaArray` (`HMTLib.Scholion[]`): An array of `Scholion` objects.
*   **Returns:** (`String | null`) The CTS URN of the Iliad passage, or `null` if not found.

### `HMTLib.scholiaforpassage(iliadPassageUrn, scholiaArray)`

Finds all scholia URNs that refer to a specific Iliad passage URN.

*   **Parameters:**
    *   `iliadPassageUrn` (String): The CTS URN of the Iliad passage.
    *   `scholiaArray` (`HMTLib.Scholion[]`): An array of `Scholion` objects.
*   **Returns:** (`String[]`) An array of scholion CTS URNs.

---

## Metadata and Utility Functions

### `HMTLib.collectionlabel(collectionCite2Urn, parserInstance)`

Retrieves the human-readable label (description) for a CITE2 collection from the `citecollections` data.

*   **Parameters:**
    *   `collectionCite2Urn` (String): The CITE2 URN of the collection.
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`String | null`) The description of the collection, or `null` if not found or an error occurs.

### `HMTLib.textlabel(textCtsUrn, parserInstance)`

Retrieves and formats a human-readable label for a CTS text URN from the `ctscatalog` data.

*   **Parameters:**
    *   `textCtsUrn` (String): The CTS URN of the text.
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`String | null`) The formatted label, or `null` if not found or an error occurs.
    *   Example format: "GroupName, WorkTitle (VersionLabel) ExemplarLabel"

### `HMTLib.codexlist(parserInstance)`

Retrieves a list of CITE2 URNs for collections that are identified as codices, based on the `urn:cite2:hmt:datamodels.v1:codexmodel` in the `datamodels` block. Uses the `CEXParser.getCollectionsForModel()` method.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
*   **Returns:** (`String[]`) An array of CITE2 URN strings for codex collections.

### `HMTLib.codexmenu(parserInstance, selectName, selectId)`

Builds an HTML `<select>` menu string for choosing a codex. It uses `HMTLib.codexlist` to get the URNs and `HMTLib.collectionlabel` to get the display text for each option.

*   **Parameters:**
    *   `parserInstance` (`CEXParser`): A `CEXParser` instance loaded with HMT data.
    *   `selectName` (String): The desired `name` attribute for the `<select>` element.
    *   `selectId` (String): The desired `id` attribute for the `<select>` element.
*   **Returns:** (`String`) An HTML string representing the complete `<select>` element with its options.
*   **Example:**
    ```javascript
    // Assuming 'hmtParser' is a loaded CEXParser instance
    const menuHtml = HMTLib.codexmenu(hmtParser, "codex_select", "codexSelector");
    document.getElementById("menu-container").innerHTML = menuHtml;
    ```

---
```

This documentation should give users a good understanding of how to use your `HMTLib.js` library. You can copy and paste this directly into a `.md` file in your GitHub repository. Good luck with the publication!